\section{imo 1974 p3}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma sum_mod5_ne_zero (n : ℕ) :
    (∑ k in Finset.range (n + 1),
        Nat.choose (2 * n + 1) (2 * k + 1) * 2 ^ (3 * k)) % 5 ≠ 0 := by
  have h :
      (∑ k in Finset.range (n + 1),
          Nat.choose (2 * n + 1) (2 * k + 1) * 2 ^ (3 * k)) % 5 ≠ 0 := by
    have h₁ :
        ∀ n : ℕ,
          (∑ k in Finset.range (n + 1),
              Nat.choose (2 * n + 1) (2 * k + 1) * 2 ^ (3 * k)) % 5 ≠ 0 := by
      intro n
      induction n using Nat.strong_induction_on with
      | h n ih =>
        match n with
        | 0 =>
          norm_num [Finset.sum_range_succ, Nat.choose_succ_succ, Nat.pow_succ]
        | 1 =>
          norm_num [Finset.sum_range_succ, Nat.choose_succ_succ, Nat.pow_succ]
        | 2 =>
          norm_num [Finset.sum_range_succ, Nat.choose_succ_succ, Nat.pow_succ]
        | 3 =>
          norm_num [Finset.sum_range_succ, Nat.choose_succ_succ, Nat.pow_succ]
        | 4 =>
          norm_num [Finset.sum_range_succ, Nat.choose_succ_succ, Nat.pow_succ]
        | n + 5 =>
          
          have h₂ := ih (n + 4) (by omega)
          have h₃ := ih (n + 3) (by omega)
          have h₄ := ih (n + 2) (by omega)
          have h₅ := ih (n + 1) (by omega)
          have h₆ := ih n (by omega)
          simp [Finset.sum_range_succ, Nat.choose_succ_succ, Nat.pow_add,
                Nat.mul_add, Nat.add_mul] at h₂ h₃ h₄ h₅ h₆ ⊢
          <;> (try omega) <;>
          (try
            {
              ring_nf at h₂ h₃ h₄ h₅ h₆ ⊢
              <;> omega
            }) <;>
          (try
            {
              norm_num at h₂ h₃ h₄ h₅ h₆ ⊢
              <;> omega
            }) <;>
          (try
            {
              cases n <;> simp_all [Finset.sum_range_succ,
                                    Nat.choose_succ_succ,
                                    Nat.pow_add, Nat.mul_add,
                                    Nat.add_mul] <;>
                (try omega) <;>
                (try
                  {
                    ring_nf at *
                    <;> omega
                  }) <;>
                (try
                  {
                    norm_num at *
                    <;> omega
                  })
            })
    exact h₁ n
  exact h

theorem imo_1974_p3 (n : ℕ) :
    ¬5 ∣ ∑ k in Finset.range (n + 1), Nat.choose (2 * n + 1) (2 * k + 1) * 2 ^ (3 * k) := by
  intro h
  have h₁ :
      (∑ k in Finset.range (n + 1),
          Nat.choose (2 * n + 1) (2 * k + 1) * 2 ^ (3 * k)) % 5 = 0 := by
    omega
  have h₂ :
      (∑ k in Finset.range (n + 1),
          Nat.choose (2 * n + 1) (2 * k + 1) * 2 ^ (3 * k)) % 5 ≠ 0 :=
    sum_mod5_ne_zero n
  omega
\end{lstlisting}
\end{thought}\section{amc12b 2020 p6}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma factorial_succ_two (n : ℕ) :
    (n + 2)! = (n + 2) * (n + 1)! := by
  rw [Nat.factorial_succ]
  <;> simp [Nat.factorial_succ, Nat.mul_assoc]
  <;> ring_nf
  <;> simp [Nat.factorial_succ, Nat.mul_assoc]
  <;> nlinarith

lemma factorial_succ_one (n : ℕ) :
    (n + 1)! = (n + 1) * n ! := by
  rw [Nat.factorial_succ]
  <;> simp [Nat.factorial_succ, Nat.mul_assoc]
  <;> ring_nf
  <;> simp [Nat.factorial_succ, Nat.mul_assoc]
  <;> nlinarith

lemma diff_factorial (n : ℕ) (h₀ : 9 ≤ n) :
    (n + 2)! - (n + 1)! = (n + 1) * (n + 1)! := by
  rw [factorial_succ_two, factorial_succ_one]
  have h₁ : (n + 2) * ((n + 1) * n !) ≥ (n + 1) * n ! := by
    have h₂ : n + 2 ≥ 1 := by linarith
    have h₃ : (n + 2) * ((n + 1) * n !) ≥ (n + 1) * n ! := by
      nlinarith [Nat.mul_le_mul_right ((n + 1) * n !) (by linarith : 1 ≤ n + 2)]
    exact h₃
  have h₄ : (n + 2) * ((n + 1) * n !) - (n + 1) * n ! = (n + 1) * ((n + 1) * n !) := by
    have h₅ : (n + 2) * ((n + 1) * n !) ≥ (n + 1) * n ! := h₁
    have h₆ : (n + 2) * ((n + 1) * n !) - (n + 1) * n ! = (n + 1) * ((n + 1) * n !) := by
      calc
        (n + 2) * ((n + 1) * n !) - (n + 1) * n ! 
            = (n + 2) * ((n + 1) * n !) - (n + 1) * n ! := rfl
        _ = (n + 1) * ((n + 1) * n !) := by
          have h₇ : (n + 2) * ((n + 1) * n !) = (n + 1) * ((n + 1) * n !) + (n + 1) * n ! := by
            ring_nf
            <;> simp [Nat.mul_add, Nat.add_mul, Nat.mul_one, Nat.mul_zero]
            <;> nlinarith
          rw [h₇]
          <;> simp [Nat.add_sub_cancel]
          <;> ring_nf
          <;> simp [Nat.mul_add, Nat.add_mul, Nat.mul_one, Nat.mul_zero]
          <;> nlinarith
        _ = (n + 1) * ((n + 1) * n !) := rfl
    exact h₆
  calc
    (n + 2) * ((n + 1) * n !) - (n + 1) * n ! 
        = (n + 1) * ((n + 1) * n !) := h₄
    _ = (n + 1) * (n + 1)! := by
          rw [factorial_succ_one]
          <;> ring_nf
          <;> simp [Nat.mul_assoc]
          <;> nlinarith

lemma final_eq (n : ℕ) (h₀ : 9 ≤ n) :
    (n + 2)! - (n + 1)! = (n + 1) ^ 2 * n ! := by
  rw [diff_factorial n h₀]
  rw [factorial_succ_one]
  <;> ring_nf
  <;> simp [Nat.pow_succ, Nat.mul_assoc]
  <;> nlinarith

lemma factorial_sub_eq (n : ℕ) (h₀ : 9 ≤ n) :
    (n + 2)! - (n + 1)! = (n + 1) ^ 2 * n ! := by
  exact final_eq n h₀
lemma factorial_succ_two_1 (n : ℕ) :
    (n + 2)! = (n + 2) * (n + 1)! := by
  rw [Nat.factorial_succ]
  <;> simp [Nat.factorial_succ, Nat.mul_succ]
  <;> ring
  <;> simp_all [Nat.factorial_succ, Nat.mul_succ]
  <;> linarith

lemma factorial_succ_one_1 (n : ℕ) :
    (n + 1)! = (n + 1) * n ! := by
  rw [Nat.factorial_succ]
  <;> simp [Nat.factorial_succ, Nat.mul_succ]
  <;> ring
  <;> simp_all [Nat.factorial_succ, Nat.mul_succ]
  <;> linarith

lemma factorial_sub_eq_nat (n : ℕ) (h₀ : 9 ≤ n) :
    ((n + 2)! - (n + 1)! : ℝ) = (n + 1 : ℝ) ^ 2 * (n ! : ℝ) := by
  have h₁ : (n + 2)! = (n + 2) * (n + 1)! := factorial_succ_two_1 n
  have h₂ : (n + 1)! = (n + 1) * n ! := factorial_succ_one_1 n
  have h₃ : ((n + 2)! - (n + 1)! : ℝ) = (n + 1 : ℝ) ^ 2 * (n ! : ℝ) := by
    rw [h₁, h₂]
    <;> norm_num
    <;> ring_nf
    <;> field_simp [Nat.cast_add_one_ne_zero]
    <;> ring_nf
    <;> norm_num
    <;> linarith
  exact h₃

lemma factorial_sub_eq_real (n : ℕ) (h₀ : 9 ≤ n) :
    ((n + 2)! - (n + 1)! : ℝ) = (n + 1 : ℝ) ^ 2 * (n ! : ℝ) := by
  exact factorial_sub_eq_nat n h₀
lemma fraction_eq_square (n : ℕ) (h₀ : 9 ≤ n) :
    (((n + 2)! - (n + 1)!) : ℝ) / (n ! : ℝ) = (n + 1 : ℝ) ^ 2 := by
  have h₂ := factorial_sub_eq_real (n:=n) h₀
  rw [h₂]
  have h₃ : (n ! : ℝ) ≠ 0 := by
    norm_cast
    apply Nat.factorial_ne_zero
  field_simp [h₃]
  <;> ring_nf
  <;> field_simp [h₃]
  <;> nlinarith

theorem amc12b_2020_p6 (n : ℕ) (h₀ : 9 ≤ n) : ∃ x : ℕ, (x : ℝ) ^ 2 = ((n + 2)! - (n + 1)!) / n ! := by
  refine ⟨n + 1, ?_⟩
  have h₃ := fraction_eq_square (n:=n) h₀
  calc
    ((n + 1 : ℕ) : ℝ) ^ 2 = (n + 1 : ℝ) ^ 2 := by norm_cast
    _ = (((n + 2)! - (n + 1)!) : ℝ) / (n ! : ℝ) := by
      rw [h₃]
      <;> norm_num
    _ = ((n + 2)! - (n + 1)!) / n ! := by
      norm_num [Nat.cast_add, Nat.cast_one, Nat.cast_mul, Nat.cast_sub]
      <;> field_simp [Nat.cast_ne_zero]
      <;> ring_nf
      <;> norm_num
      <;> simp_all [Nat.factorial_succ, Nat.mul_assoc]
      <;> nlinarith
\end{lstlisting}
\end{thought}\section{mathd numbertheory 235}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma mod_result : (29 * 79 + 31 * 81) % 10 = 2 := by
  norm_num

theorem mathd_numbertheory_235 : (29 * 79 + 31 * 81) % 10 = 2 := by
  exact mod_result
\end{lstlisting}
\end{thought}\section{algebra amgm sum1toneqn prod1tonleq1}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma sum_eq_n_real (a : ℕ → NNReal) (n : ℕ)
    (h₀ : (∑ x in Finset.range n, a x) = n) :
    (∑ x in Finset.range n, (a x : ℝ)) = n := by
  norm_cast at h₀ ⊢
  <;> simp_all [Finset.sum_const, Finset.card_range]
  <;> norm_num
  <;> linarith

lemma prod_le_one_real (a : ℕ → NNReal) (n : ℕ)
    (h₁ : (∑ x in Finset.range n, (a x : ℝ)) = n) :
    (∏ x in Finset.range n, (a x : ℝ)) ≤ 1 := by
  by_cases hn : n = 0
  · subst hn
    simp [Finset.prod_range_zero]
  · have hn' : n > 0 := Nat.pos_of_ne_zero hn
    by_cases h₃ : ∃ x ∈ Finset.range n, (a x : ℝ) = 0
    · obtain ⟨x, hx, hx0⟩ := h₃
      have h₅ : (∏ y in Finset.range n, (a y : ℝ)) = 0 := by
        apply Finset.prod_eq_zero hx
        simp [hx0]
      rw [h₅]
      norm_num
    · have h₄ : ∀ x ∈ Finset.range n, (a x : ℝ) > 0 := by
        intro x hx
        have h₅ : (a x : ℝ) ≠ 0 := by
          intro h₅
          have : (a x : ℝ) = 0 := h₅
          have : (a x : ℝ) = 0 := by simpa using this
          have : (a x : ℝ) = 0 := this
          have : (a x : ℝ) = 0 := this
          have h₆ : (a x : ℝ) = 0 := this
          have h₇ : (a x : ℝ) = 0 := h₆
          have h₈ : (a x : ℝ) = 0 := h₇
          have h₉ : (a x : ℝ) = 0 := h₈
          have h₁₀ : (a x : ℝ) = 0 := h₉
          exfalso
          apply h₃
          exact ⟨x, hx, by simpa using h₁₀⟩
        have h₆ : (a x : ℝ) ≥ 0 := by
          exact_mod_cast (a x).prop
        have h₇ : (a x : ℝ) > 0 := by
          contrapose! h₅
          linarith
        exact h₇
      have h₅ : (∏ x in Finset.range n, (a x : ℝ)) ≤ 1 := by
        have h₆ : (∑ x in Finset.range n, (a x : ℝ)) = n := h₁
        have h₇ : (∏ x in Finset.range n, (a x : ℝ)) ≤ 1 := by
          have h₈ : ∀ x ∈ Finset.range n, (a x : ℝ) > 0 := h₄
          have h₉ : (∏ x in Finset.range n, (a x : ℝ)) > 0 := by
            apply Finset.prod_pos
            intro i hi
            exact h₈ i hi
          have h₁₀ : Real.log (∏ x in Finset.range n, (a x : ℝ)) ≤ 0 := by
            have h₁₁ : Real.log (∏ x in Finset.range n, (a x : ℝ)) =
                ∑ x in Finset.range n, Real.log ((a x : ℝ)) := by
              rw [Real.log_prod _ _ fun i hi => (h₈ i hi).ne']
              <;> simp [Real.log_mul]
            rw [h₁₁]
            have h₁₂ : ∑ x in Finset.range n, Real.log ((a x : ℝ)) ≤ 0 := by
              have h₁₃ : ∑ x in Finset.range n, Real.log ((a x : ℝ)) ≤
                  ∑ x in Finset.range n, ((a x : ℝ) - 1) := by
                apply Finset.sum_le_sum
                intro i hi
                have h₁₄ : Real.log ((a i : ℝ)) ≤ (a i : ℝ) - 1 := by
                  have h₁₅ : (a i : ℝ) > 0 := h₈ i hi
                  have h₁₆ : Real.log ((a i : ℝ)) ≤ (a i : ℝ) - 1 := by
                    linarith [Real.log_le_sub_one_of_pos h₁₅]
                  exact h₁₆
                exact h₁₄
              have h₁₇ : ∑ x in Finset.range n, ((a x : ℝ) - 1) =
                  (∑ x in Finset.range n, (a x : ℝ)) - n := by
                calc
                  ∑ x in Finset.range n, ((a x : ℝ) - 1) =
                      ∑ x in Finset.range n, ((a x : ℝ) - 1) := rfl
                  _ = (∑ x in Finset.range n, (a x : ℝ)) -
                      ∑ x in Finset.range n, (1 : ℝ) := by
                      rw [Finset.sum_sub_distrib]
                      <;> simp [Finset.sum_const]
                      <;> ring
                  _ = (∑ x in Finset.range n, (a x : ℝ)) - n := by
                      simp [Finset.sum_const, Finset.card_range]
                      <;> ring
                      <;> field_simp [hn']
                      <;> ring
                  _ = (∑ x in Finset.range n, (a x : ℝ)) - n := by rfl
              have h₁₈ : (∑ x in Finset.range n, (a x : ℝ)) = n := h₁
              have h₁₉ : ∑ x in Finset.range n, ((a x : ℝ) - 1) = 0 := by
                rw [h₁₇, h₁₈]
                <;> simp [hn']
                <;> ring
                <;> field_simp [hn']
                <;> ring
              linarith
            linarith
          have h₂₀ : Real.log (∏ x in Finset.range n, (a x : ℝ)) ≤ 0 := h₁₀
          have h₂₁ : (∏ x in Finset.range n, (a x : ℝ)) ≤ 1 := by
            by_contra h₂₂
            have h₂₃ : (∏ x in Finset.range n, (a x : ℝ)) > 1 := by linarith
            have h₂₄ : Real.log (∏ x in Finset.range n, (a x : ℝ)) > 0 := by
              have h₂₅ : Real.log (∏ x in Finset.range n, (a x : ℝ)) >
                  Real.log 1 := by
                apply Real.log_lt_log (by positivity)
                linarith
              have h₂₆ : Real.log 1 = (0 : ℝ) := by norm_num
              linarith
            linarith
          exact h₂₁
        exact h₇
      exact h₅
  <;> norm_num

lemma prod_le_one_nnreal (a : ℕ → NNReal) (n : ℕ)
    (h₂ : (∏ x in Finset.range n, (a x : ℝ)) ≤ 1) :
    (∏ x in Finset.range n, a x) ≤ 1 := by
  have h₃ : (∏ x in Finset.range n, a x : ℝ) ≤ 1 := by
    calc
      (∏ x in Finset.range n, a x : ℝ) = ∏ x in Finset.range n, (a x : ℝ) := by
        simp [Finset.prod_range]
        <;> norm_cast
        <;> simp [Finset.prod_range]
        <;> norm_cast
      _ ≤ 1 := h₂
  have h₄ : (∏ x in Finset.range n, a x : ℝ) ≤ 1 := h₃
  have h₅ : (∏ x in Finset.range n, a x) ≤ 1 := by
    exact_mod_cast h₄
  exact h₅

theorem algebra_amgm_sum1toneqn_prod1tonleq1 (a : ℕ → NNReal) (n : ℕ)
    (h₀ : (∑ x in Finset.range n, a x) = n) : (∏ x in Finset.range n, a x) ≤ 1 := by
  have h₁ := sum_eq_n_real a n h₀
  have h₂ := prod_le_one_real a n h₁
  have h₃ := prod_le_one_nnreal a n h₂
  exact h₃
\end{lstlisting}
\end{thought}\section{mathd algebra 153}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma floor_10n (n : ℝ) (h₀ : n = 1 / 3) :
    Int.floor (10 * n) = 3 := by
  have h₁ : Int.floor (10 * n) = 3 := by
    rw [h₀]
    norm_num [Int.floor_eq_iff, mul_comm]
    <;> try norm_num
    <;> try linarith
    <;> try ring_nf
    <;> try norm_num
    <;> try linarith
  exact h₁

lemma floor_100n (n : ℝ) (h₀ : n = 1 / 3) :
    Int.floor (100 * n) = 33 := by
  have h₂ : Int.floor (100 * n) = 33 := by
    rw [h₀]
    norm_num [Int.floor_eq_iff, mul_comm]
    <;> try norm_num
    <;> try linarith
    <;> try ring_nf
    <;> try norm_num
    <;> try linarith
  exact h₂

lemma floor_1000n (n : ℝ) (h₀ : n = 1 / 3) :
    Int.floor (1000 * n) = 333 := by
  have h₃ : Int.floor (1000 * n) = 333 := by
    rw [h₀]
    norm_num [Int.floor_eq_iff, mul_comm]
    <;> try norm_num
    <;> try linarith
    <;> try ring_nf
    <;> try norm_num
    <;> try linarith
  exact h₃

lemma floor_10000n (n : ℝ) (h₀ : n = 1 / 3) :
    Int.floor (10000 * n) = 3333 := by
  have h₄ : Int.floor (10000 * n) = 3333 := by
    rw [h₀]
    norm_num [Int.floor_eq_iff, mul_comm]
    <;> try norm_num
    <;> try linarith
    <;> try ring_nf
    <;> try norm_num
    <;> try linarith
  exact h₄

theorem mathd_algebra_153 (n : ℝ) (h₀ : n = 1 / 3) :
    Int.floor (10 * n) + Int.floor (100 * n) + Int.floor (1000 * n) + Int.floor (10000 * n) = 3702 := by
  have h1 := floor_10n n h₀
  have h2 := floor_100n n h₀
  have h3 := floor_1000n n h₀
  have h4 := floor_10000n n h₀
  rw [h1, h2, h3, h4]
  <;> norm_num
  <;> linarith
\end{lstlisting}
\end{thought}\section{algebra ineq nto1onlt2m1on}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma one_add_mul_le_pow_add_one (n : ℕ) (x : ℝ) (hx : x ≥ 0) :
    (1 + x : ℝ) ^ n ≥ 1 + n * x := by
  induction' n with n ih
  · norm_num
  ·
    cases n with
    | zero =>
        norm_num [pow_one]
        <;> nlinarith
    | succ n =>
        simp_all [pow_succ, mul_add, add_mul, mul_assoc] <;>
        nlinarith [sq_nonneg x, mul_nonneg hx (by positivity : (0 : ℝ) ≤ n.succ)]

lemma two_sub_one_div_eq_one_add (n : ℕ) (hn : n ≥ 1) :
    (2 - 1 / (n : ℝ)) = 1 + ((n - 1 : ℝ) / n) := by
  have h₁ : (n : ℝ) ≥ 1 := by exact_mod_cast hn
  field_simp [h₁] <;> ring_nf <;> field_simp [h₁] <;> ring_nf <;> nlinarith

lemma pow_two_sub_one_div_ge_n (n : ℕ) (hn : n ≥ 1) :
    (2 - 1 / (n : ℝ)) ^ n ≥ (n : ℝ) := by
  have h₁ : (n : ℝ) ≥ 1 := by exact_mod_cast hn
  have h₂ : (2 - 1 / (n : ℝ)) = 1 + ((n - 1 : ℝ) / n) := by
    rw [two_sub_one_div_eq_one_add (n:=n) hn]
  rw [h₂]
  have h₃ : ((n - 1 : ℝ) / n : ℝ) ≥ 0 := by
    have h₄ : (n : ℝ) ≥ 1 := by exact_mod_cast hn
    have h₅ : (n : ℝ) - 1 ≥ 0 := by linarith
    positivity
  have h₄ : (1 + ((n - 1 : ℝ) / n) : ℝ) ^ n ≥ 1 + n * (((n - 1 : ℝ) / n)) := by
    have h₅ : (1 + ((n - 1 : ℝ) / n) : ℝ) ≥ 1 := by
      have h₅₁ : ((n - 1 : ℝ) / n : ℝ) ≥ 0 := h₃
      linarith
    have h₆ : (1 + ((n - 1 : ℝ) / n) : ℝ) ^ n ≥ 1 + n * (((n - 1 : ℝ) / n)) := by
      have h₇ : ∀ (m : ℕ) (y : ℝ), y ≥ 0 → (1 + y : ℝ) ^ m ≥ 1 + m * y := by
        intro m y hy
        induction' m with m ih
        · norm_num
        ·
          cases m with
          | zero =>
              norm_num [pow_one] <;> nlinarith
          | succ m =>
              simp_all [pow_succ, mul_add, add_mul, mul_assoc] <;>
              nlinarith [sq_nonneg y, mul_nonneg hy (by positivity : (0 : ℝ) ≤ m.succ)]
      have h₈ : ((n - 1 : ℝ) / n : ℝ) ≥ 0 := h₃
      have h₉ : (1 + ((n - 1 : ℝ) / n) : ℝ) ^ n ≥ 1 + n * (((n - 1 : ℝ) / n)) := by
        have h₁₀ := h₇ n (((n - 1 : ℝ) / n)) h₈
        linarith
      exact h₉
    exact h₆
  have h₅ : (1 + n * (((n - 1 : ℝ) / n)) : ℝ) = (n : ℝ) := by
    have h₅₁ : (n : ℝ) ≥ 1 := by exact_mod_cast hn
    have h₅₂ : (n : ℝ) > 0 := by linarith
    field_simp [h₅₂.ne'] <;> ring_nf <;> field_simp [h₅₂.ne'] <;> nlinarith
  have h₆ : (1 + ((n - 1 : ℝ) / n) : ℝ) ^ n ≥ (n : ℝ) := by
    linarith
  linarith

lemma pow_inequality (n : ℕ) (hn : n ≥ 1) :
    (2 - 1 / (n : ℝ)) ^ n ≥ (n : ℝ) := by
  exact pow_two_sub_one_div_ge_n (n:=n) hn
lemma final_inequality (n : ℕ) (hn : n ≥ 1) :
    (n : ℝ) ^ ((1 : ℝ) / n) ≤ 2 - 1 / (n : ℝ) := by
  have h₁ : (n : ℝ) ≥ 1 := by exact_mod_cast hn
  have h₂ : (n : ℝ) > 0 := by linarith
  have h₃ : (2 - 1 / (n : ℝ)) > 0 := by
    have h₄ : (n : ℝ) ≥ 1 := by exact_mod_cast hn
    have h₅ : (1 : ℝ) / (n : ℝ) ≤ 1 := by
      rw [div_le_iff (by positivity)]
      nlinarith
    have h₆ : (2 : ℝ) - 1 / (n : ℝ) > 0 := by
      have h₇ : (1 : ℝ) / (n : ℝ) ≥ 0 := by positivity
      have h₈ : (1 : ℝ) / (n : ℝ) ≤ 1 := by
        rw [div_le_iff (by positivity)]
        nlinarith
      nlinarith
    linarith
  have h₄ : (n : ℝ) ^ ((1 : ℝ) / n) ≤ 2 - 1 / (n : ℝ) := by
    have h₅ : Real.log ((n : ℝ) ^ ((1 : ℝ) / n)) = (1 / (n : ℝ)) * Real.log (n : ℝ) := by
      rw [Real.log_rpow (by positivity)]
      <;> field_simp <;> ring
    have h₆ : Real.log (2 - 1 / (n : ℝ)) ≥ (1 / (n : ℝ)) * Real.log (n : ℝ) := by
      have h₇ : (2 - 1 / (n : ℝ)) ^ n ≥ (n : ℝ) := pow_inequality n hn
      have h₈ : Real.log ((2 - 1 / (n : ℝ)) ^ n) ≥ Real.log (n : ℝ) := by
        apply Real.log_le_log
        ·
          have h₉ : (2 - 1 / (n : ℝ)) > 0 := h₃
          have h₁₀ : (2 - 1 / (n : ℝ)) ^ n > 0 := by positivity
          linarith
        ·
          linarith
      have h₉ : Real.log ((2 - 1 / (n : ℝ)) ^ n) = n * Real.log (2 - 1 / (n : ℝ)) := by
        rw [Real.log_pow]
        <;> field_simp <;> ring
        <;> linarith
      have h₁₀ : n * Real.log (2 - 1 / (n : ℝ)) ≥ Real.log (n : ℝ) := by linarith
      have h₁₁ : Real.log (2 - 1 / (n : ℝ)) ≥ (1 / (n : ℝ)) * Real.log (n : ℝ) := by
        have h₁₂ : (n : ℝ) > 0 := by positivity
        have h₁₃ : Real.log (2 - 1 / (n : ℝ)) ≥ (1 / (n : ℝ)) * Real.log (n : ℝ) := by
          calc
            Real.log (2 - 1 / (n : ℝ))
                = (1 / (n : ℝ)) * (n * Real.log (2 - 1 / (n : ℝ))) := by
                  field_simp [h₁₂.ne'] <;> ring
            _ ≥ (1 / (n : ℝ)) * Real.log (n : ℝ) := by
                  have h₁₄ : (n : ℝ) * Real.log (2 - 1 / (n : ℝ)) ≥ Real.log (n : ℝ) := by linarith
                  have h₁₅ : (1 / (n : ℝ)) > 0 := by positivity
                  nlinarith
            _ = (1 / (n : ℝ)) * Real.log (n : ℝ) := by ring
        exact h₁₃
      linarith
    have h₇ : Real.log ((n : ℝ) ^ ((1 : ℝ) / n)) ≤ Real.log (2 - 1 / (n : ℝ)) := by
      have h₈ : Real.log ((n : ℝ) ^ ((1 : ℝ) / n)) = (1 / (n : ℝ)) * Real.log (n : ℝ) := h₅
      rw [h₈]
      linarith
    have h₈ : (n : ℝ) ^ ((1 : ℝ) / n) ≤ 2 - 1 / (n : ℝ) := by
      by_contra h₉
      have h₁₀ : (n : ℝ) ^ ((1 : ℝ) / n) > 2 - 1 / (n : ℝ) := by linarith
      have h₁₁ : Real.log ((n : ℝ) ^ ((1 : ℝ) / n)) > Real.log (2 - 1 / (n : ℝ)) := by
        apply Real.log_lt_log (by
          have h₁₂ : (n : ℝ) ^ ((1 : ℝ) / n) > 0 := by positivity
          linarith) h₁₀
      linarith
    exact h₈
  exact h₄

theorem algebra_ineq_nto1onlt2m1on (n : ℕ) : (n : ℝ) ^ ((1 : ℝ) / n) ≤ 2 - 1 / n := by
  by_cases h : n = 0
  ·
    subst h
    norm_num
    <;> simp_all [Nat.cast_zero]
    <;> norm_num
    <;> linarith
  ·
    have h₁ : n ≥ 1 := by
      by_contra h₁
      have h₂ : n = 0 := by
        omega
      contradiction
    have h₂ : (n : ℝ) ^ ((1 : ℝ) / n) ≤ 2 - 1 / (n : ℝ) := final_inequality n h₁
    simpa [h] using h₂
\end{lstlisting}
\end{thought}\section{mathd algebra 276}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma ab_eq_ten (a b : ℤ)
    (h₀ : ∀ x : ℝ, 10 * x ^ 2 - x - 24 = (a * x - 8) * (b * x + 3)) :
    a * b = 10 := by
  have h₁₀ := h₀ 1
  have h₁₁ := h₀ (-1)
  have h₁₂ := h₀ 2
  have h₁₃ := h₀ (-2)
  have h₁₄ := h₀ 0
  have h₁₅ := h₀ (1 / 2)
  have h₁₆ := h₀ (-1 / 2)
  norm_num at h₁₀ h₁₁ h₁₂ h₁₃ h₁₄ h₁₅ h₁₆
  ring_nf at h₁₀ h₁₁ h₁₂ h₁₃ h₁₄ h₁₅ h₁₆
  norm_cast at h₁₀ h₁₁ h₁₂ h₁₃ h₁₄ h₁₅ h₁₆
  <;>
  (try norm_num at h₁₀ h₁₁ h₁₂ h₁₃ h₁₄ h₁₅ h₁₆) <;>
  (try ring_nf at h₁₀ h₁₁ h₁₂ h₁₃ h₁₄ h₁₅ h₁₆) <;>
  (try norm_num) <;>
  (try
    {
      nlinarith [sq_nonneg (a - 5), sq_nonneg (b - 2), sq_nonneg (a + 5), sq_nonneg (b + 2),
        sq_nonneg (a - 1), sq_nonneg (b - 1), sq_nonneg (a + 1), sq_nonneg (b + 1)]
    }) <;>
  (try
    {
      have h₁₇ : a * b = 10 := by
        nlinarith [sq_nonneg (a - 5), sq_nonneg (b - 2), sq_nonneg (a + 5), sq_nonneg (b + 2),
          sq_nonneg (a - 1), sq_nonneg (b - 1), sq_nonneg (a + 1), sq_nonneg (b + 1)]
      exact h₁₇
    }) <;>
  (try
    {
      omega
    })
  <;>
  (try
    {
      nlinarith
    })
  <;>
  (try
    {
      linarith
    })
  <;>
  (try
    {
      nlinarith
    })

lemma three_a_sub_eight_b_eq_neg_one (a b : ℤ)
    (h₀ : ∀ x : ℝ, 10 * x ^ 2 - x - 24 = (a * x - 8) * (b * x + 3)) :
    3 * a - 8 * b = -1 := by
  have h₂₀ := h₀ 1
  have h₂₁ := h₀ (-1)
  have h₂₂ := h₀ 2
  have h₂₃ := h₀ (-2)
  have h₂₄ := h₀ 0
  have h₂₅ := h₀ (1 / 2)
  have h₂₆ := h₀ (-1 / 2)
  norm_num at h₂₀ h₂₁ h₂₂ h₂₃ h₂₄ h₂₅ h₂₆
  ring_nf at h₂₀ h₂₁ h₂₂ h₂₃ h₂₄ h₂₅ h₂₆
  norm_cast at h₂₀ h₂₁ h₂₂ h₂₃ h₂₄ h₂₅ h₂₆
  <;>
  (try norm_num at h₂₀ h₂₁ h₂₂ h₂₃ h₂₄ h₂₅ h₂₆) <;>
  (try ring_nf at h₂₀ h₂₁ h₂₂ h₂₃ h₂₄ h₂₅ h₂₆) <;>
  (try norm_num) <;>
  (try
    {
      nlinarith [sq_nonneg (a - 5), sq_nonneg (b - 2), sq_nonneg (a + 5), sq_nonneg (b + 2),
        sq_nonneg (a - 1), sq_nonneg (b - 1), sq_nonneg (a + 1), sq_nonneg (b + 1)]
    }) <;>
  (try
    {
      have h₂₇ : 3 * a - 8 * b = -1 := by
        nlinarith [sq_nonneg (a - 5), sq_nonneg (b - 2), sq_nonneg (a + 5), sq_nonneg (b + 2),
          sq_nonneg (a - 1), sq_nonneg (b - 1), sq_nonneg (a + 1), sq_nonneg (b + 1)]
      exact h₂₇
    }) <;>
  (try
    {
      omega
    })
  <;>
  (try
    {
      nlinarith
    })
  <;>
  (try
    {
      linarith
    })
  <;>
  (try
    {
      nlinarith
    })

lemma a_eq_five (a b : ℤ)
    (h₀ : ∀ x : ℝ, 10 * x ^ 2 - x - 24 = (a * x - 8) * (b * x + 3))
    (h₁ : a * b = 10) (h₂ : 3 * a - 8 * b = -1) :
    a = 5 := by
  have h₃₁ : a = 5 := by
    have h₃₂ : a * b = 10 := h₁
    have h₃₃ : 3 * a - 8 * b = -1 := h₂
    have h₃₄ : b ≠ 0 := by
      by_contra h
      rw [h] at h₃₂
      norm_num at h₃₂
      <;> omega
    have h₃₅ : a ≠ 0 := by
      by_contra h
      rw [h] at h₃₂
      norm_num at h₃₂
      <;> omega
    have h₃₆ : b = 2 := by
      have h₃₇ : a * b = 10 := h₁
      have h₃₈ : 3 * a - 8 * b = -1 := h₂
      have h₃₉ : b = 2 := by
        
        have h₄₀ : b ∣ 10 := by
          use a
          <;> linarith
        have h₄₁ : b = 1 ∨ b = 2 ∨ b = 5 ∨ b = 10 ∨ b = -1 ∨ b = -2 ∨ b = -5 ∨ b = -10 := by
          have h₄₂ : b ∣ 10 := h₄₀
          have h₄₃ : b = 1 ∨ b = 2 ∨ b = 5 ∨ b = 10 ∨ b = -1 ∨ b = -2 ∨ b = -5 ∨ b = -10 := by
            rw [← Int.natAbs_dvd_natAbs] at h₄₂
            have h₄₄ : b.natAbs ∣ 10 := by
              simpa [Int.natAbs] using h₄₂
            have h₄₅ : b.natAbs = 1 ∨ b.natAbs = 2 ∨ b.natAbs = 5 ∨ b.natAbs = 10 := by
              have h₄₆ : b.natAbs ∣ 10 := h₄₄
              have h₄₇ : b.natAbs ≤ 10 := Nat.le_of_dvd (by norm_num) h₄₆
              interval_cases b.natAbs <;> norm_num at h₄₆ ⊢ <;> omega
            rcases h₄₅ with (h₄₅ | h₄₅ | h₄₅ | h₄₅) <;>
              (try omega) <;>
              (try
                {
                  have h₄₈ : b = 1 ∨ b = -1 := by
                    omega
                  rcases h₄₈ with (h₄₈ | h₄₈) <;>
                    simp_all [h₄₈] <;>
                    omega
                }) <;>
              (try
                {
                  have h₄₈ : b = 2 ∨ b = -2 := by
                    omega
                  rcases h₄₈ with (h₄₈ | h₄₈) <;>
                    simp_all [h₄₈] <;>
                    omega
                }) <;>
              (try
                {
                  have h₄₈ : b = 5 ∨ b = -5 := by
                    omega
                  rcases h₄₈ with (h₄₈ | h₄₈) <;>
                    simp_all [h₄₈] <;>
                    omega
                }) <;>
              (try
                {
                  have h₄₈ : b = 10 ∨ b = -10 := by
                    omega
                  rcases h₄₈ with (h₄₈ | h₄₈) <;>
                    simp_all [h₄₈] <;>
                    omega
                })
          rcases h₄₃ with (h₄₃ | h₄₃ | h₄₃ | h₄₃ | h₄₃ | h₄₃ | h₄₃ | h₄₃) <;>
            (try omega) <;>
            (try
              {
                simp_all [h₄₃] <;>
                omega
              })
        rcases h₄₁ with (h₄₁ | h₄₁ | h₄₁ | h₄₁ | h₄₁ | h₄₁ | h₄₁ | h₄₁) <;>
          (try omega) <;>
          (try
            {
              simp_all [h₄₁] <;>
              omega
            })
      exact h₃₉
    have h₄₀ : a = 5 := by
      have h₄₁ : a * b = 10 := h₁
      have h₄₂ : 3 * a - 8 * b = -1 := h₂
      have h₄₃ : b = 2 := h₃₆
      rw [h₄₃] at h₄₁ h₄₂
      <;> norm_num at h₄₁ h₄₂ ⊢ <;>
        (try omega) <;>
        (try nlinarith)
    exact h₄₀
  exact h₃₁

lemma b_eq_two (a b : ℤ)
    (h₀ : ∀ x : ℝ, 10 * x ^ 2 - x - 24 = (a * x - 8) * (b * x + 3))
    (h₁ : a * b = 10) (h₂ : 3 * a - 8 * b = -1) (h₃ : a = 5) :
    b = 2 := by
  have h₄₁ : b = 2 := by
    have h₄₂ : a * b = 10 := h₁
    have h₄₃ : 3 * a - 8 * b = -1 := h₂
    have h₄₄ : a = 5 := h₃
    rw [h₄₄] at h₄₂ h₄₃
    <;> norm_num at h₄₂ h₄₃ ⊢ <;>
      (try omega) <;>
      (try nlinarith)
  exact h₄₁

theorem mathd_algebra_276 (a b : ℤ)
    (h₀ : ∀ x : ℝ, 10 * x ^ 2 - x - 24 = (a * x - 8) * (b * x + 3)) : a * b + b = 12 := by
  have h₁ : a * b = 10 := ab_eq_ten a b h₀
  have h₂ : 3 * a - 8 * b = -1 := three_a_sub_eight_b_eq_neg_one a b h₀
  have h₃ : a = 5 := a_eq_five a b h₀ h₁ h₂
  have h₄ : b = 2 := b_eq_two a b h₀ h₁ h₂ h₃
  have h₅ : a * b + b = 12 := by
    rw [h₃, h₄]
    <;> norm_num
    <;> linarith
  exact h₅
\end{lstlisting}
\end{thought}\section{mathd algebra 176}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma expand_sq (x : ℝ) : (x + 1) ^ 2 = x ^ 2 + 2 * x + 1 := by
  calc
    (x + 1) ^ 2 = (x + 1) * (x + 1) := by ring
    _ = x ^ 2 + 2 * x + 1 := by ring

lemma mul_expand (x : ℝ) : (x ^ 2 + 2 * x + 1) * x = x ^ 3 + 2 * x ^ 2 + x := by
  ring

theorem mathd_algebra_176 (x : ℝ) : (x + 1) ^ 2 * x = x ^ 3 + 2 * x ^ 2 + x := by
  calc
    (x + 1) ^ 2 * x = (x ^ 2 + 2 * x + 1) * x := by
      rw [expand_sq x]
    _ = x ^ 3 + 2 * x ^ 2 + x := by
      rw [mul_expand x]
\end{lstlisting}
\end{thought}\section{induction prod1p1onk3le3m1onn}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma base_case :
    ∏ k in Finset.Icc 1 (1 : ℕ), (1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / (1 : ℝ) := by
  norm_num [Finset.prod_Icc_succ_top]
  <;> simp [Finset.prod_range_succ, Nat.cast_add, Nat.cast_one, Nat.cast_zero]
  <;> norm_num
  <;> linarith


lemma prod_split (m : ℕ) (hm : 0 < m) :
    ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) =
      (∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3) := by
  have h₁ :
      ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) =
        (∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3) := by
    have h₂ : ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) =
        ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) := rfl
    rw [h₂]
    have h₃ : ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) =
        (∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3) := by
      have h₄ : ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) =
          (∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3) := by
        have h₅ : ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) =
            ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) := rfl
        rw [h₅]
        have h₆ : ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) =
            (∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3) := by
          have h₇ : m + 1 > 0 := by linarith
          have h₈ : ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) =
              (∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3) := by
            have h₉ : ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) =
                (∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3) := by
              calc
                ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) =
                    ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) := rfl
                _ = (∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3) := by
                  have h₁₀ :
                      Finset.Icc 1 (m + 1) = Finset.Icc 1 m ∪ {m + 1} := by
                    ext x
                    simp [Finset.mem_Icc, Nat.lt_succ_iff] <;>
                      (try omega) <;>
                      (try
                        {
                          by_cases h : x ≤ m <;> by_cases h' : x = m + 1 <;>
                            simp_all [Nat.lt_succ_iff, Nat.le_of_lt_succ,
                                      Nat.succ_le_iff] <;> omega
                        }) <;>
                      (try omega)
                  rw [h₁₀]
                  rw [Finset.prod_union]
                  <;> simp [Finset.disjoint_left, Finset.mem_Icc] <;>
                    (try omega) <;>
                    (try
                      {
                        by_cases h : x ≤ m <;> by_cases h' : x = m + 1 <;>
                          simp_all [Nat.lt_succ_iff, Nat.le_of_lt_succ,
                                    Nat.succ_le_iff] <;> omega
                      }) <;>
                    (try omega)
                  <;>
                    (try
                      {
                        norm_num
                        <;>
                        (try omega)
                        <;>
                        (try
                          {
                            ring_nf
                            <;>
                            field_simp
                            <;>
                            ring_nf
                            <;>
                            norm_num
                            <;>
                            linarith
                          })
                      })
                  <;>
                    (try
                      {
                        norm_num
                        <;>
                        (try omega)
                        <;>
                        (try
                          {
                            ring_nf
                            <;>
                            field_simp
                            <;>
                            ring_nf
                            <;>
                            norm_num
                            <;>
                            linarith
                          })
                      })
                _ = (∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3) := by
                  rfl
            exact h₉
          exact h₈
        exact h₆
      exact h₄
    exact h₃
  exact h₁

lemma prod_bound (m : ℕ) (hm : 0 < m)
    (h_ind :
        ∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / (m : ℝ)) :
    (∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3)) ≤ (3 : ℝ) - 1 / (m : ℝ) := by
  simpa [Nat.cast_add, Nat.cast_one, Nat.cast_zero, Nat.cast_succ] using h_ind

lemma main_inequality (m : ℕ) (hm : 0 < m) :
    ((3 : ℝ) - 1 / (m : ℝ)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3) ≤ (3 : ℝ) - 1 / ((m : ℝ) + 1) := by
  have h₁ : 0 < (m : ℝ) := by exact_mod_cast hm
  have h₂ : 0 < (m : ℝ) + 1 := by linarith
  have h₃ : 0 < (m : ℝ) + 1 + 1 := by linarith
  have h₄ : 0 < (m : ℝ) ^ 2 := by positivity
  have h₅ : 0 < (m : ℝ) ^ 3 := by positivity
  have h₆ : 0 < (m : ℝ) ^ 4 := by positivity
  have h₇ : 0 < (m : ℝ) ^ 5 := by positivity
  have h₈ : 0 < (m : ℝ) ^ 6 := by positivity
  field_simp
  rw [div_le_div_iff (by positivity) (by positivity)]
  ring_nf
  nlinarith
    [sq_nonneg ((m : ℝ) ^ 2 - (m : ℝ)), sq_nonneg ((m : ℝ) ^ 3 - (m : ℝ) ^ 2),
      sq_nonneg ((m : ℝ) ^ 2 - 1), sq_nonneg ((m : ℝ) ^ 3 - 1),
      sq_nonneg ((m : ℝ) ^ 4 - (m : ℝ) ^ 3), sq_nonneg ((m : ℝ) ^ 3 - (m : ℝ)),
      sq_nonneg ((m : ℝ) ^ 4 - (m : ℝ) ^ 2), sq_nonneg ((m : ℝ) ^ 4 - (m : ℝ))]

lemma inductive_step (m : ℕ) (hm : 0 < m)
    (h_ind :
        ∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / (m : ℝ)) :
    ∏ k in Finset.Icc 1 (m + 1), (1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ((m + 1 : ℕ) : ℝ) := by
  have h_split := prod_split (m := m) hm
  rw [h_split]
  have h_bound := prod_bound (m := m) hm h_ind
  have h_main := main_inequality (m := m) hm
  calc
    (∏ k in Finset.Icc 1 m, (1 + (1 : ℝ) / k ^ 3)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3)
        ≤ ((3 : ℝ) - 1 / (m : ℝ)) * (1 + (1 : ℝ) / (m + 1 : ℝ) ^ 3) := by
          gcongr
    _ ≤ (3 : ℝ) - 1 / ((m : ℝ) + 1) := by
          exact h_main
    _ = (3 : ℝ) - 1 / ((m + 1 : ℕ) : ℝ) := by
          norm_num [Nat.cast_add, Nat.cast_one, Nat.cast_zero, Nat.cast_succ]
          <;> field_simp
          <;> ring_nf
          <;> norm_num
          <;> linarith
  <;> norm_num
  <;> linarith
theorem induction_prod1p1onk3le3m1onn (n : ℕ) (h₀ : 0 < n) :
    ∏ k in Finset.Icc 1 n, (1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
  have h_main :
      ∀ (n : ℕ), 0 < n →
        ∏ k in Finset.Icc 1 n, (1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / (n : ℝ) := by
    intro n hn
    induction' hn with n hn IH
    · 
      norm_num [Finset.prod_Icc_succ_top]
      <;> simp [Finset.prod_range_succ, Nat.cast_add, Nat.cast_one, Nat.cast_zero]
      <;> norm_num
      <;> linarith
    · 
      cases n with
      | zero =>
          norm_num at hn ⊢
          <;> simp_all [Finset.prod_Icc_succ_top]
          <;> norm_num
          <;> linarith
      | succ n =>
          have h₁ := inductive_step (n + 1) (by simp_all [Nat.succ_eq_add_one])
            (by
              
              simpa [Finset.prod_Icc_succ_top, Nat.cast_add, Nat.cast_one,
                    Nat.cast_zero] using IH)
          simpa [Finset.prod_Icc_succ_top, Nat.cast_add, Nat.cast_one,
                Nat.cast_zero] using h₁
  exact h_main n h₀
\end{lstlisting}
\end{thought}\section{mathd algebra 392}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma sq_eq (n : ℕ)
    (h₁ : (↑n - 2) ^ 2 + ↑n ^ 2 + (↑n + 2) ^ 2 = (12296 : ℤ)) :
    (n : ℤ) ^ 2 = 4096 := by
  have h₂₁ : (n : ℤ) ^ 2 = 4096 := by
    have h₂₂ := h₁
    ring_nf at h₂₂ ⊢
    nlinarith [sq_nonneg ((n : ℤ) - 2), sq_nonneg ((n : ℤ) + 2)]
  exact h₂₁

lemma nat_sq_eq (n : ℕ) (h₂ : (n : ℤ) ^ 2 = 4096) : n ^ 2 = 4096 := by
  have h₃₁ : (n : ℤ) ^ 2 = 4096 := h₂
  have h₃₂ : (n : ℕ) ^ 2 = 4096 := by
    norm_cast at h₃₁ ⊢
    <;>
    (try norm_num at h₃₁ ⊢) <;>
    (try nlinarith) <;>
    (try ring_nf at h₃₁ ⊢) <;>
    (try nlinarith)
    <;>
    (try
      {
        nlinarith
      })
  exact h₃₂

lemma n_eq_64 (n : ℕ) (h₃ : n ^ 2 = 4096) : n = 64 := by
  have h₄₁ : n ≤ 64 := by
    nlinarith
  interval_cases n <;> norm_num at h₃ ⊢ <;>
    (try omega) <;>
    (try nlinarith) <;>
    (try ring_nf at h₃ ⊢) <;>
    (try norm_num at h₃ ⊢) <;>
    (try omega)

lemma product_eq (n : ℕ) (h₄ : n = 64) :
    (↑n - 2) * ↑n * (↑n + 2) / 8 = (32736 : ℤ) := by
  rw [h₄]
  <;> norm_num
  <;> ring_nf
  <;> norm_num
  <;> linarith

theorem mathd_algebra_392 (n : ℕ) (h₀ : Even n)
    (h₁ : (↑n - 2) ^ 2 + ↑n ^ 2 + (↑n + 2) ^ 2 = (12296 : ℤ)) :
    (↑n - 2) * ↑n * (↑n + 2) / 8 = (32736 : ℤ) := by
  have h₂ : (n : ℤ) ^ 2 = 4096 := sq_eq n h₁
  have h₃ : n ^ 2 = 4096 := nat_sq_eq n h₂
  have h₄ : n = 64 := n_eq_64 n h₃
  exact product_eq n h₄
\end{lstlisting}
\end{thought}\section{amc12 2000 p6}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma prime_le_18_cases (p : ℕ) (hp : Nat.Prime p) (h₁ : 4 ≤ p ∧ p ≤ 18) :
    p = 5 ∨ p = 7 ∨ p = 11 ∨ p = 13 ∨ p = 17 := by
  have h₃₁ : p ≥ 4 := h₁.1
  have h₃₂ : p ≤ 18 := h₁.2
  interval_cases p <;> norm_num [Nat.Prime] at hp ⊢ <;>
    (try contradiction) <;>
    (try norm_num) <;>
    (try omega) <;>
    (try aesop)

lemma prime_le_18_cases' (q : ℕ) (hq : Nat.Prime q) (h₂ : 4 ≤ q ∧ q ≤ 18) :
    q = 5 ∨ q = 7 ∨ q = 11 ∨ q = 13 ∨ q = 17 := by
  have h₄₁ : q ≥ 4 := h₂.1
  have h₄₂ : q ≤ 18 := h₂.2
  interval_cases q <;> norm_num [Nat.Prime] at hq ⊢ <;>
    (try contradiction) <;>
    (try norm_num) <;>
    (try omega) <;>
    (try aesop)



lemma h_main (p q : ℕ) (h₀ : Nat.Prime p ∧ Nat.Prime q)
    (h₁ : 4 ≤ p ∧ p ≤ 18) (h₂ : 4 ≤ q ∧ q ≤ 18) :
    (p * q : ℕ) - (p + q) ≠ 194 := by
  have h₃ := prime_le_18_cases p h₀.1 h₁
  have h₄ := prime_le_18_cases' q h₀.2 h₂
  rcases h₃ with (rfl | rfl | rfl | rfl | rfl) <;>
    rcases h₄ with (rfl | rfl | rfl | rfl | rfl) <;>
      norm_num [Nat.mul_sub_left_distrib, Nat.mul_sub_right_distrib,
                Nat.add_assoc] at h₀ ⊢ <;>
        (try omega) <;>
        (try norm_num) <;>
        (try contradiction) <;>
        (try ring_nf at * <;> omega)

theorem amc12_2000_p6 (p q : ℕ) (h₀ : Nat.Prime p ∧ Nat.Prime q) (h₁ : 4 ≤ p ∧ p ≤ 18)
    (h₂ : 4 ≤ q ∧ q ≤ 18) : ↑p * ↑q - (↑p + ↑q) ≠ (194 : ℕ) := by
  have h := h_main p q h₀ h₁ h₂
  exact h
\end{lstlisting}
\end{thought}\section{mathd algebra 432}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma expand_product (x : ℝ) : (x + 3) * (2 * x - 6) = 2 * x ^ 2 - 18 := by
  ring_nf

theorem mathd_algebra_432 (x : ℝ) : (x + 3) * (2 * x - 6) = 2 * x ^ 2 - 18 := by
  exact expand_product x
\end{lstlisting}
\end{thought}\section{mathd algebra 76}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma four_is_even : Even (4 : ℤ) := by
  norm_num [Int.even_iff, Int.odd_iff] <;> decide


lemma f_four_eq (f : ℤ → ℤ)
    (h₀ : ∀ n, Odd n → f n = n ^ 2)
    (h₁ : ∀ n, Even n → f n = n ^ 2 - 4 * n - 1) :
    f 4 = -1 := by
  have h₂ : f 4 = (4 : ℤ) ^ 2 - 4 * (4 : ℤ) - 1 := by
    apply h₁
    exact four_is_even
  rw [h₂]
  norm_num

theorem mathd_algebra_76 (f : ℤ → ℤ) (h₀ : ∀ n, Odd n → f n = n ^ 2)
    (h₁ : ∀ n, Even n → f n = n ^ 2 - 4 * n - 1) : f 4 = -1 := by
  exact f_four_eq f h₀ h₁
\end{lstlisting}
\end{thought}\section{amc12a 2020 p10}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma log_two_pos : Real.log 2 > 0 := by
  have : Real.log 2 > 0 := Real.log_pos (by norm_num)
  exact this

lemma log_n_pos (n : ℕ) (h₀ : 1 < n) : Real.log (n : ℝ) > 0 := by
  have h₂₁ : (n : ℝ) > 1 := by exact_mod_cast h₀
  have h₂₂ : Real.log (n : ℝ) > 0 := Real.log_pos (by
    norm_num at h₂₁ ⊢ <;> linarith)
  exact h₂₂

lemma log16_eq : Real.log 16 = 4 * Real.log 2 := by
  have h₃₁ : Real.log 16 = Real.log (2 ^ 4) := by norm_num
  rw [h₃₁]
  have h₃₂ : Real.log (2 ^ 4) = 4 * Real.log 2 := by
    rw [Real.log_pow] <;> norm_num
  rw [h₃₂]
  <;> norm_num

lemma log4_eq : Real.log 4 = 2 * Real.log 2 := by
  have h₄₁ : Real.log 4 = Real.log (2 ^ 2) := by norm_num
  rw [h₄₁]
  have h₄₂ : Real.log (2 ^ 2) = 2 * Real.log 2 := by
    rw [Real.log_pow] <;> norm_num
  rw [h₄₂]
  <;> norm_num

lemma logb16_eq (n : ℕ) (h₀ : 1 < n) :
    Real.logb 16 (n : ℝ) = Real.log (n : ℝ) / (4 * Real.log 2) := by
  have h₅₁ :
      Real.logb 16 (n : ℝ) = Real.log (n : ℝ) / Real.log 16 := by
    rw [Real.logb]
    <;> field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀]
    <;> ring
    <;> norm_num
    <;> linarith
  rw [h₅₁]
  have h₅₂ : Real.log 16 = 4 * Real.log 2 := log16_eq
  rw [h₅₂]
  <;> field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀]
  <;> ring
  <;> norm_num
  <;> linarith

lemma logb4_eq (n : ℕ) (h₀ : 1 < n) :
    Real.logb 4 (n : ℝ) = Real.log (n : ℝ) / (2 * Real.log 2) := by
  have h₆₁ :
      Real.logb 4 (n : ℝ) = Real.log (n : ℝ) / Real.log 4 := by
    rw [Real.logb]
    <;> field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀]
    <;> ring
    <;> norm_num
    <;> linarith
  rw [h₆₁]
  have h₆₂ : Real.log 4 = 2 * Real.log 2 := log4_eq
  rw [h₆₂]
  <;> field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀]
  <;> ring
  <;> norm_num
  <;> linarith

lemma h2_eq (n : ℕ) (h₀ : 1 < n)
    (h₁ : Real.logb 2 (Real.logb 16 n) = Real.logb 4 (Real.logb 4 n)) :
    Real.log (Real.log (n : ℝ)) = Real.log (8 * Real.log 2) := by
  have h₇₁ : Real.logb 2 (Real.logb 16 (n : ℝ)) = Real.logb 4 (Real.logb 4 (n : ℝ)) := by
    simpa using h₁
  have h₇₂ : Real.logb 16 (n : ℝ) = Real.log (n : ℝ) / (4 * Real.log 2) := logb16_eq n h₀
  have h₇₃ : Real.logb 4 (n : ℝ) = Real.log (n : ℝ) / (2 * Real.log 2) := logb4_eq n h₀
  have h₇₄ :
      Real.logb 2 (Real.logb 16 (n : ℝ)) =
        Real.log (Real.logb 16 (n : ℝ)) / Real.log 2 := by
    rw [Real.logb]
    <;> field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀]
    <;> ring
    <;> norm_num
    <;> linarith
  have h₇₅ :
      Real.logb 4 (Real.logb 4 (n : ℝ)) =
        Real.log (Real.logb 4 (n : ℝ)) / Real.log 4 := by
    rw [Real.logb]
    <;> field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀]
    <;> ring
    <;> norm_num
    <;> linarith
  rw [h₇₄, h₇₅] at h₇₁
  have h₇₆ : Real.log 4 = 2 * Real.log 2 := log4_eq
  rw [h₇₆] at h₇₁
  have h₇₇ : Real.logb 16 (n : ℝ) = Real.log (n : ℝ) / (4 * Real.log 2) := logb16_eq n h₀
  have h₇₈ : Real.logb 4 (n : ℝ) = Real.log (n : ℝ) / (2 * Real.log 2) := logb4_eq n h₀
  rw [h₇₇, h₇₈] at h₇₁
  have h₇₉ :
      Real.log (Real.log (n : ℝ) / (4 * Real.log 2)) / Real.log 2 =
        Real.log (Real.log (n : ℝ) / (2 * Real.log 2)) / (2 * Real.log 2) := by
    linarith
  have h₇₁₀ : Real.log (n : ℝ) > 0 := log_n_pos n h₀
  have h₇₁₁ : Real.log 2 > 0 := log_two_pos
  have h₇₁₂ : Real.log (Real.log (n : ℝ) / (4 * Real.log 2)) =
        Real.log (Real.log (n : ℝ)) - Real.log (4 * Real.log 2) := by
    have h₇₁₃ : Real.log (Real.log (n : ℝ) / (4 * Real.log 2)) =
        Real.log (Real.log (n : ℝ)) - Real.log (4 * Real.log 2) := by
      have h₇₁₄ : Real.log (Real.log (n : ℝ) / (4 * Real.log 2)) =
          Real.log (Real.log (n : ℝ)) - Real.log (4 * Real.log 2) := by
        rw [Real.log_div (by positivity) (by positivity)]
        <;> field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀]
        <;> ring
        <;> norm_num
        <;> linarith
      exact h₇₁₄
    exact h₇₁₃
  have h₇₁₃ : Real.log (Real.log (n : ℝ) / (2 * Real.log 2)) =
        Real.log (Real.log (n : ℝ)) - Real.log (2 * Real.log 2) := by
    have h₇₁₄ : Real.log (Real.log (n : ℝ) / (2 * Real.log 2)) =
        Real.log (Real.log (n : ℝ)) - Real.log (2 * Real.log 2) := by
      have h₇₁₅ : Real.log (Real.log (n : ℝ) / (2 * Real.log 2)) =
          Real.log (Real.log (n : ℝ)) - Real.log (2 * Real.log 2) := by
        rw [Real.log_div (by positivity) (by positivity)]
        <;> field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀]
        <;> ring
        <;> norm_num
        <;> linarith
      exact h₇₁₅
    exact h₇₁₄
  have h₇₁₄ : Real.log (4 * Real.log 2) = Real.log 4 + Real.log (Real.log 2) := by
    have h₇₁₅ : Real.log (4 * Real.log 2) = Real.log 4 + Real.log (Real.log 2) := by
      have h₇₁₆ : Real.log (4 * Real.log 2) = Real.log 4 + Real.log (Real.log 2) := by
        rw [Real.log_mul (by positivity) (by positivity)]
        <;> field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀]
        <;> ring
        <;> norm_num
        <;> linarith
      exact h₇₁₆
    exact h₇₁₅
  have h₇₁₅ : Real.log (2 * Real.log 2) = Real.log 2 + Real.log (Real.log 2) := by
    have h₇₁₆ : Real.log (2 * Real.log 2) = Real.log 2 + Real.log (Real.log 2) := by
      have h₇₁₇ : Real.log (2 * Real.log 2) = Real.log 2 + Real.log (Real.log 2) := by
        rw [Real.log_mul (by positivity) (by positivity)]
        <;> field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀]
        <;> ring
        <;> norm_num
        <;> linarith
      exact h₇₁₇
    exact h₇₁₆
  have h₇₁₆ : Real.log 4 = 2 * Real.log 2 := log4_eq
  rw [h₇₁₂, h₇₁₃, h₇₁₄, h₇₁₅, h₇₁₆] at h₇₉
  have h₇₁₇ :
      (Real.log (Real.log (n : ℝ)) - (2 * Real.log 2 + Real.log (Real.log 2))) / Real.log 2 =
        (Real.log (Real.log (n : ℝ)) - (Real.log 2 + Real.log (Real.log 2))) / (2 * Real.log 2) := by
    linarith
  have h₇₁₈ :
      2 * (Real.log (Real.log (n : ℝ)) - (2 * Real.log 2 + Real.log (Real.log 2))) =
        Real.log (Real.log (n : ℝ)) - (Real.log 2 + Real.log (Real.log 2)) := by
    field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀] at h₇₁₇ ⊢
    <;> ring_nf at h₇₁₇ ⊢
    <;> nlinarith [Real.log_pos (by norm_num : (1 : ℝ) < 2)]
  have h₇₁₉ :
      Real.log (Real.log (n : ℝ)) = 3 * Real.log 2 + Real.log (Real.log 2) := by
    linarith
  have h₇₂₀ : Real.log (8 * Real.log 2) = 3 * Real.log 2 + Real.log (Real.log 2) := by
    have h₇₂₁ : Real.log (8 * Real.log 2) = Real.log 8 + Real.log (Real.log 2) := by
      have h₇₂₂ : Real.log (8 * Real.log 2) = Real.log 8 + Real.log (Real.log 2) := by
        rw [Real.log_mul (by positivity) (by positivity)]
        <;> field_simp [Real.log_mul, Real.log_rpow, Real.log_pow, h₀]
        <;> ring
        <;> norm_num
        <;> linarith
      exact h₇₂₂
    have h₇₂₃ : Real.log 8 = 3 * Real.log 2 := by
      have h₇₂₄ : Real.log 8 = Real.log (2 ^ 3) := by norm_num
      rw [h₇₂₄]
      have h₇₂₅ : Real.log (2 ^ 3) = 3 * Real.log 2 := by
        rw [Real.log_pow] <;> norm_num
      rw [h₇₂₅]
      <;> ring
    rw [h₇₂₁, h₇₂₃]
    <;> ring
    <;> linarith
  linarith

lemma log_eq_8_log2 (n : ℕ) (h₀ : 1 < n)
    (h₁ : Real.logb 2 (Real.logb 16 n) = Real.logb 4 (Real.logb 4 n)) :
    Real.log (n : ℝ) = 8 * Real.log 2 := by
  have h₈₁ : Real.log (Real.log (n : ℝ)) = Real.log (8 * Real.log 2) := h2_eq n h₀ h₁
  have h₈₂ : Real.log (n : ℝ) = 8 * Real.log 2 := by
    have h₈₃ : Real.log (n : ℝ) > 0 := log_n_pos n h₀
    have h₈₄ : 8 * Real.log 2 > 0 := by positivity
    have h₈₅ : Real.log (Real.log (n : ℝ)) = Real.log (8 * Real.log 2) := h₈₁
    have h₈₆ : Real.log (n : ℝ) = 8 * Real.log 2 := by
      apply Real.log_injOn_pos (Set.mem_Ioi.mpr h₈₃) (Set.mem_Ioi.mpr h₈₄)
      linarith
    exact h₈₆
  exact h₈₂

lemma log_n_eq_8_log2 (n : ℕ) (h₀ : 1 < n)
    (h₁ : Real.logb 2 (Real.logb 16 n) = Real.logb 4 (Real.logb 4 n)) :
    Real.log n = 8 * Real.log 2 := by
  have h₈ := log_eq_8_log2 n h₀ h₁
  simpa using h₈
lemma n_eq_256 (n : ℕ) (h₀ : 1 < n)
    (h₁ : Real.logb 2 (Real.logb 16 n) = Real.logb 4 (Real.logb 4 n)) :
    n = 256 := by
  have h₂ : Real.log n = 8 * Real.log 2 := log_n_eq_8_log2 n h₀ h₁
  have h₃ : (n : ℝ) = 256 := by
    have h₄ : Real.log n = Real.log (256 : ℝ) := by
      have h₅ : Real.log (256 : ℝ) = 8 * Real.log 2 := by
        have h₅₁ : Real.log (256 : ℝ) = Real.log (2 ^ 8) := by norm_num
        rw [h₅₁]
        have h₅₂ : Real.log (2 ^ 8 : ℝ) = 8 * Real.log 2 := by
          rw [Real.log_pow]
          <;> norm_num
          <;> linarith
        rw [h₅₂]
        <;> norm_num
      linarith
    have h₆ : (n : ℝ) = 256 := by
      have h₇ : Real.log (n : ℝ) = Real.log (256 : ℝ) := by
        simpa using h₄
      have h₈ : (n : ℝ) = 256 := by
        apply Real.log_injOn_pos (Set.mem_Ioi.mpr (by positivity)) (Set.mem_Ioi.mpr (by positivity))
        linarith
      exact h₈
    exact h₆
  have h₇ : n = 256 := by
    norm_cast at h₃ ⊢
    <;> simp_all [Nat.cast_inj]
    <;> linarith
  exact h₇


lemma sum_digits_256 : List.sum (Nat.digits 10 256) = 13 := by
  norm_num [Nat.digits_len]
  <;> rfl

theorem amc12a_2020_p10 (n : ℕ) (h₀ : 1 < n)
    (h₁ : Real.logb 2 (Real.logb 16 n) = Real.logb 4 (Real.logb 4 n)) :
    (List.sum (Nat.digits 10 n)) = 13 := by
  have h₂ : n = 256 := n_eq_256 n h₀ h₁
  rw [h₂]
  exact sum_digits_256
\end{lstlisting}
\end{thought}\section{aime 1983 p3}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma f_eq_zero_iff (f : ℝ → ℝ)
    (h₀ : ∀ x, f x = x ^ 2 + (18 * x + 30) - 2 * Real.sqrt (x ^ 2 + (18 * x + 45)))
    (h₁ : Fintype (f ⁻¹' {0})) :
    ∀ x : ℝ, f x = 0 ↔ x = -9 + Real.sqrt 61 ∨ x = -9 - Real.sqrt 61 := by
  intro x
  rw [h₀]
  constructor
  · intro h
    have h₂ : x ^ 2 + (18 * x + 30) - 2 * Real.sqrt (x ^ 2 + (18 * x + 45)) = 0 := by linarith
    have h₃ : Real.sqrt (x ^ 2 + (18 * x + 45)) ≥ 0 := Real.sqrt_nonneg _
    have h₄ : x ^ 2 + (18 * x + 30) = 2 * Real.sqrt (x ^ 2 + (18 * x + 45)) := by linarith
    have h₅ : x ^ 2 + (18 * x + 45) ≥ 0 := by
      by_contra h₅
      have h₆ : x ^ 2 + (18 * x + 45) < 0 := by linarith
      have h₇ : Real.sqrt (x ^ 2 + (18 * x + 45)) = 0 := by
        rw [Real.sqrt_eq_zero_of_nonpos] <;> linarith
      rw [h₇] at h₄
      nlinarith [Real.sqrt_nonneg (x ^ 2 + (18 * x + 45)),
        Real.sq_sqrt (show 0 ≤ 61 by norm_num)]
    have h₆ : (x ^ 2 + (18 * x + 30)) ^ 2 = 4 * (x ^ 2 + (18 * x + 45)) := by
      nlinarith [Real.sq_sqrt (show 0 ≤ x ^ 2 + (18 * x + 45) by linarith),
        sq_nonneg (x ^ 2 + (18 * x + 30) - 2 * Real.sqrt (x ^ 2 + (18 * x + 45)))]
    have h₇ : x = -9 + Real.sqrt 61 ∨ x = -9 - Real.sqrt 61 := by
      have h₈ : x ^ 2 + 18 * x + 20 = 0 := by
        nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num),
          Real.sqrt_nonneg 61,
          sq_nonneg (x + 9)]
      have h₉ : x = -9 + Real.sqrt 61 ∨ x = -9 - Real.sqrt 61 := by
        have h₁₀ : x = -9 + Real.sqrt 61 ∨ x = -9 - Real.sqrt 61 := by
          apply or_iff_not_imp_left.mpr
          intro h₁₁
          apply mul_left_cancel₀ (sub_ne_zero.mpr h₁₁)
          nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num),
            Real.sqrt_nonneg 61,
            sq_nonneg (x + 9)]
        exact h₁₀
      exact h₉
    exact h₇
  · intro h
    cases h with
    | inl h =>
      have h₂ : x = -9 + Real.sqrt 61 := h
      rw [h₂]
      have h₃ : Real.sqrt ((-9 + Real.sqrt 61) ^ 2 + (18 * (-9 + Real.sqrt 61) + 45)) = 5 := by
        have h₄ : Real.sqrt ((-9 + Real.sqrt 61) ^ 2 + (18 * (-9 + Real.sqrt 61) + 45)) = 5 := by
          rw [Real.sqrt_eq_iff_sq_eq] <;>
            nlinarith [Real.sqrt_nonneg 61,
              Real.sq_sqrt (show 0 ≤ 61 by norm_num),
              sq_nonneg (Real.sqrt 61 - 9)]
        rw [h₄]
      rw [h₃]
      nlinarith [Real.sqrt_nonneg 61,
        Real.sq_sqrt (show 0 ≤ 61 by norm_num),
        sq_nonneg (Real.sqrt 61 - 9)]
    | inr h =>
      have h₂ : x = -9 - Real.sqrt 61 := h
      rw [h₂]
      have h₃ : Real.sqrt ((-9 - Real.sqrt 61) ^ 2 + (18 * (-9 - Real.sqrt 61) + 45)) = 5 := by
        have h₄ : Real.sqrt ((-9 - Real.sqrt 61) ^ 2 + (18 * (-9 - Real.sqrt 61) + 45)) = 5 := by
          rw [Real.sqrt_eq_iff_sq_eq] <;>
            nlinarith [Real.sqrt_nonneg 61,
              Real.sq_sqrt (show 0 ≤ 61 by norm_num),
              sq_nonneg (Real.sqrt 61 + 9)]
        rw [h₄]
      rw [h₃]
      nlinarith [Real.sqrt_nonneg 61,
        Real.sq_sqrt (show 0 ≤ 61 by norm_num),
        sq_nonneg (Real.sqrt 61 + 9)]


lemma prod_f_preimage (f : ℝ → ℝ)
    (h₀ : ∀ x, f x = x ^ 2 + (18 * x + 30) - 2 * Real.sqrt (x ^ 2 + (18 * x + 45)))
    (h₁ : Fintype (f ⁻¹' {0})) :
    (∏ x in (f ⁻¹' {0}).toFinset, x) = 20 := by
  have h₂ : (f ⁻¹' {0}).toFinset = { -9 + Real.sqrt 61, -9 - Real.sqrt 61 } := by
    apply Finset.ext
    intro x
    simp only [Finset.mem_insert, Finset.mem_singleton, Set.mem_preimage,
      Set.mem_singleton_iff]
    constructor
    · intro h
      have h₃ : f x = 0 := by simpa using h
      have h₄ : x = -9 + Real.sqrt 61 ∨ x = -9 - Real.sqrt 61 :=
        (f_eq_zero_iff f h₀ h₁) x |>.mp h₃
      cases h₄ with
      | inl h₄ => simp [h₄]
      | inr h₄ => simp [h₄]
    · intro h
      have h₃ : x = -9 + Real.sqrt 61 ∨ x = -9 - Real.sqrt 61 := by simpa using h
      cases h₃ with
      | inl h₃ =>
        have h₄ : f x = 0 := by
          rw [h₃]
          have h₅ : Real.sqrt ((-9 + Real.sqrt 61) ^ 2 + (18 * (-9 + Real.sqrt 61) + 45)) = 5 := by
            have h₆ : Real.sqrt ((-9 + Real.sqrt 61) ^ 2 + (18 * (-9 + Real.sqrt 61) + 45)) = 5 := by
              rw [Real.sqrt_eq_iff_sq_eq] <;>
                nlinarith [Real.sqrt_nonneg 61,
                  Real.sq_sqrt (show 0 ≤ 61 by norm_num),
                  sq_nonneg (Real.sqrt 61 - 9)]
            rw [h₆]
          rw [h₀]
          nlinarith [Real.sqrt_nonneg 61,
            Real.sq_sqrt (show 0 ≤ 61 by norm_num),
            sq_nonneg (Real.sqrt 61 - 9)]
        simpa [h₄]
      | inr h₃ =>
        have h₄ : f x = 0 := by
          rw [h₃]
          have h₅ : Real.sqrt ((-9 - Real.sqrt 61) ^ 2 + (18 * (-9 - Real.sqrt 61) + 45)) = 5 := by
            have h₆ : Real.sqrt ((-9 - Real.sqrt 61) ^ 2 + (18 * (-9 - Real.sqrt 61) + 45)) = 5 := by
              rw [Real.sqrt_eq_iff_sq_eq] <;>
                nlinarith [Real.sqrt_nonneg 61,
                  Real.sq_sqrt (show 0 ≤ 61 by norm_num),
                  sq_nonneg (Real.sqrt 61 + 9)]
            rw [h₆]
          rw [h₀]
          nlinarith [Real.sqrt_nonneg 61,
            Real.sq_sqrt (show 0 ≤ 61 by norm_num),
            sq_nonneg (Real.sqrt 61 + 9)]
        simpa [h₄]
  rw [h₂]
  have h₃ : Real.sqrt 61 ≥ 0 := Real.sqrt_nonneg _
  have h₄ : (-9 + Real.sqrt 61 : ℝ) * (-9 - Real.sqrt 61 : ℝ) = 20 := by
    nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num)]
  calc
    (∏ x in ({-9 + Real.sqrt 61, -9 - Real.sqrt 61} : Finset ℝ), x) =
        (-9 + Real.sqrt 61) * (-9 - Real.sqrt 61) := by
          simp [Finset.prod_pair (show (-9 + Real.sqrt 61 : ℝ) ≠ -9 - Real.sqrt 61 by
            nlinarith [Real.sqrt_nonneg 61,
              Real.sq_sqrt (show 0 ≤ 61 by norm_num)])]
    _ = 20 := by
          nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num)]

theorem aime_1983_p3 (f : ℝ → ℝ)
    (h₀ : ∀ x, f x = x ^ 2 + (18 * x + 30) - 2 * Real.sqrt (x ^ 2 + (18 * x + 45)))
    (h₁ : Fintype (f ⁻¹' {0})) : (∏ x in (f ⁻¹' {0}).toFinset, x) = 20 := by
  exact prod_f_preimage f h₀ h₁
\end{lstlisting}
\end{thought}\section{imo 1963 p5}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma sin_pi_div_7_ne_zero : Real.sin (Real.pi / 7) ≠ 0 := by
  have h₁ : 0 < Real.sin (Real.pi / 7) := by
    apply Real.sin_pos_of_pos_of_lt_pi
    · linarith [Real.pi_pos, Real.pi_gt_three]
    · linarith [Real.pi_pos, Real.pi_gt_three]
  linarith

lemma two_sin_pi_div_7_mul_sum_eq_sin_pi_div_7 :
    2 * Real.sin (Real.pi / 7) *
        (Real.cos (Real.pi / 7) - Real.cos (2 * Real.pi / 7) + Real.cos (3 * Real.pi / 7)) =
      Real.sin (Real.pi / 7) := by
  have h₂ : 2 * Real.sin (Real.pi / 7) * Real.cos (Real.pi / 7) = Real.sin (2 * Real.pi / 7) := by
    have h₂₁ : Real.sin (2 * Real.pi / 7) = 2 * Real.sin (Real.pi / 7) * Real.cos (Real.pi / 7) := by
      have h₂₂ : Real.sin (2 * Real.pi / 7) = Real.sin (2 * (Real.pi / 7)) := by ring
      rw [h₂₂]
      have h₂₃ : Real.sin (2 * (Real.pi / 7)) = 2 * Real.sin (Real.pi / 7) * Real.cos (Real.pi / 7) := by
        rw [Real.sin_two_mul] <;> ring
      rw [h₂₃] <;> ring
    linarith
  have h₃ : 2 * Real.sin (Real.pi / 7) * Real.cos (3 * Real.pi / 7) =
      Real.sin (4 * Real.pi / 7) - Real.sin (2 * Real.pi / 7) := by
    have h₃₁ :
        2 * Real.sin (Real.pi / 7) * Real.cos (3 * Real.pi / 7) =
          Real.sin (4 * Real.pi / 7) - Real.sin (2 * Real.pi / 7) := by
      have h₃₂ :
          2 * Real.sin (Real.pi / 7) * Real.cos (3 * Real.pi / 7) =
            Real.sin (4 * Real.pi / 7) - Real.sin (2 * Real.pi / 7) := by
        have h₃₃ :
            2 * Real.sin (Real.pi / 7) * Real.cos (3 * Real.pi / 7) =
              Real.sin (4 * Real.pi / 7) - Real.sin (2 * Real.pi / 7) := by
          have h₃₄ :
              Real.sin (4 * Real.pi / 7) - Real.sin (2 * Real.pi / 7) =
                2 * Real.sin (Real.pi / 7) * Real.cos (3 * Real.pi / 7) := by
            have h₃₅ :
                Real.sin (4 * Real.pi / 7) - Real.sin (2 * Real.pi / 7) =
                  2 * Real.sin ((4 * Real.pi / 7 - 2 * Real.pi / 7) / 2) *
                    Real.cos ((4 * Real.pi / 7 + 2 * Real.pi / 7) / 2) := by
              have h₃₆ :
                  Real.sin (4 * Real.pi / 7) - Real.sin (2 * Real.pi / 7) =
                    2 * Real.sin ((4 * Real.pi / 7 - 2 * Real.pi / 7) / 2) *
                      Real.cos ((4 * Real.pi / 7 + 2 * Real.pi / 7) / 2) := by
                rw [Real.sin_sub_sin] <;> ring_nf <;> field_simp <;> ring_nf
                <;> linarith [Real.pi_pos]
              rw [h₃₆]
            rw [h₃₅] <;> ring_nf <;> field_simp <;> ring_nf
            <;> linarith [Real.pi_pos]
          linarith
        linarith
      linarith
    linarith
  have h₄ : 2 * Real.sin (Real.pi / 7) * Real.cos (2 * Real.pi / 7) =
      Real.sin (3 * Real.pi / 7) - Real.sin (Real.pi / 7) := by
    have h₄₁ :
        2 * Real.sin (Real.pi / 7) * Real.cos (2 * Real.pi / 7) =
          Real.sin (3 * Real.pi / 7) - Real.sin (Real.pi / 7) := by
      have h₄₂ :
          2 * Real.sin (Real.pi / 7) * Real.cos (2 * Real.pi / 7) =
            Real.sin (3 * Real.pi / 7) - Real.sin (Real.pi / 7) := by
        have h₄₃ :
            Real.sin (3 * Real.pi / 7) - Real.sin (Real.pi / 7) =
              2 * Real.sin (Real.pi / 7) * Real.cos (2 * Real.pi / 7) := by
          have h₄₄ :
              Real.sin (3 * Real.pi / 7) - Real.sin (Real.pi / 7) =
                2 * Real.sin ((3 * Real.pi / 7 - Real.pi / 7) / 2) *
                  Real.cos ((3 * Real.pi / 7 + Real.pi / 7) / 2) := by
            have h₄₅ :
                Real.sin (3 * Real.pi / 7) - Real.sin (Real.pi / 7) =
                  2 * Real.sin ((3 * Real.pi / 7 - Real.pi / 7) / 2) *
                    Real.cos ((3 * Real.pi / 7 + Real.pi / 7) / 2) := by
              rw [Real.sin_sub_sin] <;> ring_nf <;> field_simp <;> ring_nf
              <;> linarith [Real.pi_pos]
            rw [h₄₅]
          rw [h₄₄] <;> ring_nf <;> field_simp <;> ring_nf
          <;> linarith [Real.pi_pos]
        linarith
      linarith
    linarith
  have h₅ : Real.sin (4 * Real.pi / 7) = Real.sin (3 * Real.pi / 7) := by
    have h₅₁ : Real.sin (4 * Real.pi / 7) = Real.sin (Real.pi - 3 * Real.pi / 7) := by
      ring
    rw [h₅₁]
    have h₅₂ : Real.sin (Real.pi - 3 * Real.pi / 7) = Real.sin (3 * Real.pi / 7) := by
      rw [Real.sin_pi_sub] <;> ring
    rw [h₅₂] <;> ring
  calc
    2 * Real.sin (Real.pi / 7) *
        (Real.cos (Real.pi / 7) - Real.cos (2 * Real.pi / 7) + Real.cos (3 * Real.pi / 7)) =
        2 * Real.sin (Real.pi / 7) * Real.cos (Real.pi / 7) +
          2 * Real.sin (Real.pi / 7) * Real.cos (3 * Real.pi / 7) -
          2 * Real.sin (Real.pi / 7) * Real.cos (2 * Real.pi / 7) := by
      ring_nf <;> linarith
    _ = Real.sin (2 * Real.pi / 7) +
          (Real.sin (4 * Real.pi / 7) - Real.sin (2 * Real.pi / 7)) -
          (Real.sin (3 * Real.pi / 7) - Real.sin (Real.pi / 7)) := by
      rw [h₂, h₃, h₄] <;> ring_nf <;> linarith
    _ = Real.sin (4 * Real.pi / 7) - Real.sin (3 * Real.pi / 7) + Real.sin (Real.pi / 7) := by
      ring_nf <;> linarith
    _ = Real.sin (Real.pi / 7) := by
      rw [h₅] <;> ring_nf <;> linarith

theorem imo_1963_p5 : Real.cos (Real.pi / 7) - Real.cos (2 * Real.pi / 7) + Real.cos (3 * Real.pi / 7) = 1 / 2 := by
  have h_main := two_sin_pi_div_7_mul_sum_eq_sin_pi_div_7
  have h_sin_ne := sin_pi_div_7_ne_zero
  have h₆ :
      Real.cos (Real.pi / 7) - Real.cos (2 * Real.pi / 7) + Real.cos (3 * Real.pi / 7) = 1 / 2 := by
    apply mul_left_cancel₀ h_sin_ne
    nlinarith [Real.sin_le_one (Real.pi / 7),
      Real.cos_le_one (Real.pi / 7),
      Real.sin_le_one (2 * Real.pi / 7),
      Real.cos_le_one (2 * Real.pi / 7),
      Real.sin_le_one (3 * Real.pi / 7),
      Real.cos_le_one (3 * Real.pi / 7),
      Real.sin_le_one (4 * Real.pi / 7),
      Real.cos_le_one (4 * Real.pi / 7)]
  exact h₆
  <;> norm_num
  <;> linarith [Real.pi_pos]
\end{lstlisting}
\end{thought}\section{mathd numbertheory 229}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma pow_mod_five_30_mod7 : 5 ^ 30 % 7 = 1 := by
  rfl

theorem mathd_numbertheory_229 : 5 ^ 30 % 7 = 1 := by
  exact pow_mod_five_30_mod7
\end{lstlisting}
\end{thought}\section{aime 1983 p1}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma log_x_ne_zero (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log x ≠ 0 := by
  by_contra h
  rw [h] at h0
  norm_num at h0 ⊢
  <;> simp_all [div_eq_mul_inv]
  <;> ring_nf at *
  <;> norm_num at *
  <;> linarith

lemma log_y_ne_zero (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log y ≠ 0 := by
  by_contra h
  rw [h] at h1
  norm_num at h1 ⊢
  <;> simp_all [div_eq_mul_inv]
  <;> ring_nf at *
  <;> norm_num at *
  <;> linarith

lemma log_w_ne_zero (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log w ≠ 0 := by
  by_contra h
  rw [h] at h0
  norm_num at h0 ⊢
  <;> simp_all [div_eq_mul_inv]
  <;> ring_nf at *
  <;> norm_num at *
  <;> linarith

lemma log_xyz_ne_zero (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log (x * y * z : ℝ) ≠ 0 := by
  by_contra h
  rw [h] at h2
  norm_num at h2 ⊢
  <;> simp_all [div_eq_mul_inv]
  <;> ring_nf at *
  <;> norm_num at *
  <;> linarith

lemma log_z_ne_zero (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log z ≠ 0 := by
  by_contra h
  have h₅₁ : Real.log z = 0 := by simpa using h
  have h₅₂ : (z : ℝ) = 1 := by
    have h₅₃ : Real.log (z : ℝ) = 0 := by simpa using h₅₁
    have h₅₄ : Real.log (z : ℝ) = 0 := by simpa using h₅₃
    have h₅₅ : (z : ℝ) = 1 := by
      apply Real.log_injOn_pos (Set.mem_Ioi.mpr (by
        norm_cast
        <;> linarith [ht.1, ht.2.1, ht.2.2])) (Set.mem_Ioi.mpr (by norm_num))
      <;> simp_all [Real.log_one]
      <;> linarith
    exact h₅₅
  have h₅₆ : (z : ℕ) = 1 := by
    norm_cast at h₅₂ ⊢
    <;> simp_all [Nat.cast_inj]
    <;> linarith
  have h₅₇ : 1 < (z : ℕ) := by simpa using ht.2.2
  linarith

lemma log_w_eq_24_log_x (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log w = 24 * Real.log x := by
  have h₆₁ : Real.log w / Real.log x = 24 := h0
  have h₆₂ : Real.log x ≠ 0 := log_x_ne_zero x y z w ht hw h0 h1 h2
  have h₆₃ : Real.log w = 24 * Real.log x := by
    have h₆₄ : Real.log w / Real.log x = 24 := h₆₁
    have h₆₅ : Real.log w = 24 * Real.log x := by
      field_simp at h₆₄ ⊢
      <;> ring_nf at h₆₄ ⊢ <;> nlinarith
    exact h₆₅
  exact h₆₃

lemma log_w_eq_40_log_y (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log w = 40 * Real.log y := by
  have h₇₁ : Real.log w / Real.log y = 40 := h1
  have h₇₂ : Real.log y ≠ 0 := log_y_ne_zero x y z w ht hw h0 h1 h2
  have h₇₃ : Real.log w = 40 * Real.log y := by
    have h₇₄ : Real.log w / Real.log y = 40 := h₇₁
    have h₇₅ : Real.log w = 40 * Real.log y := by
      field_simp at h₇₄ ⊢
      <;> ring_nf at h₇₄ ⊢ <;> nlinarith
    exact h₇₅
  exact h₇₃

lemma log_w_eq_12_log_xyz (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log w = 12 * Real.log (x * y * z : ℝ) := by
  have h₈₁ : Real.log w / Real.log (x * y * z : ℝ) = 12 := h2
  have h₈₂ : Real.log (x * y * z : ℝ) ≠ 0 := log_xyz_ne_zero x y z w ht hw h0 h1 h2
  have h₈₃ : Real.log w = 12 * Real.log (x * y * z : ℝ) := by
    have h₈₄ : Real.log w / Real.log (x * y * z : ℝ) = 12 := h₈₁
    have h₈₅ : Real.log w = 12 * Real.log (x * y * z : ℝ) := by
      field_simp at h₈₄ ⊢
      <;> ring_nf at h₈₄ ⊢ <;> nlinarith
    exact h₈₅
  exact h₈₃

lemma log_xyz_sum (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log (x * y * z : ℝ) = Real.log x + Real.log y + Real.log z := by
  have h₉₁ : Real.log (x * y * z : ℝ) = Real.log (x * y : ℝ) + Real.log z := by
    have h₉₁₁ : (x * y * z : ℝ) = (x * y : ℝ) * z := by ring
    rw [h₉₁₁]
    have h₉₁₂ : Real.log ((x * y : ℝ) * z) = Real.log (x * y : ℝ) + Real.log z := by
      have h₉₁₃ : 0 < (x * y : ℝ) := by
        norm_cast
        <;> nlinarith [ht.1, ht.2.1]
      have h₉₁₄ : 0 < (z : ℝ) := by
        norm_cast
        <;> nlinarith [ht.2.2]
      have h₉₁₅ : 0 < (x * y : ℝ) * z := by positivity
      rw [Real.log_mul (by positivity) (by positivity)]
    rw [h₉₁₂]
    <;> ring
  have h₉₂ : Real.log (x * y : ℝ) = Real.log x + Real.log y := by
    have h₉₂₁ : 0 < (x : ℝ) := by
      norm_cast
      <;> nlinarith [ht.1]
    have h₉₂₂ : 0 < (y : ℝ) := by
      norm_cast
      <;> nlinarith [ht.2.1]
    have h₉₂₃ : 0 < (x : ℝ) * y := by positivity
    rw [Real.log_mul (by positivity) (by positivity)]
    <;> ring
  rw [h₉₁, h₉₂]
  <;> ring
  <;> linarith

lemma log_x_relation (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    3 * Real.log x = 5 * Real.log y := by
  have h₁₀₁ : Real.log w = 24 * Real.log x := log_w_eq_24_log_x x y z w ht hw h0 h1 h2
  have h₁₀₂ : Real.log w = 40 * Real.log y := log_w_eq_40_log_y x y z w ht hw h0 h1 h2
  have h₁₀₃ : 24 * Real.log x = 40 * Real.log y := by linarith
  have h₁₀₄ : 3 * Real.log x = 5 * Real.log y := by linarith
  exact h₁₀₄

lemma log_x_eq_log_y_plus_log_z (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log x = Real.log y + Real.log z := by
  have h₁₁₁ : Real.log w = 24 * Real.log x := log_w_eq_24_log_x x y z w ht hw h0 h1 h2
  have h₁₁₂ : Real.log w = 12 * Real.log (x * y * z : ℝ) := log_w_eq_12_log_xyz x y z w ht hw h0 h1 h2
  have h₁₁₃ : 24 * Real.log x = 12 * Real.log (x * y * z : ℝ) := by linarith
  have h₁₁₄ : 2 * Real.log x = Real.log (x * y * z : ℝ) := by linarith
  have h₁₁₅ : Real.log (x * y * z : ℝ) = Real.log x + Real.log y + Real.log z :=
    log_xyz_sum x y z w ht hw h0 h1 h2
  have h₁₁₆ : 2 * Real.log x = Real.log x + Real.log y + Real.log z := by linarith
  have h₁₁₇ : Real.log x = Real.log y + Real.log z := by linarith
  exact h₁₁₇

lemma log_z_relation (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log z = (2 / 3 : ℝ) * Real.log y := by
  have h₁₂₁ : Real.log x = Real.log y + Real.log z :=
    log_x_eq_log_y_plus_log_z x y z w ht hw h0 h1 h2
  have h₁₂₂ : 3 * Real.log x = 5 * Real.log y :=
    log_x_relation x y z w ht hw h0 h1 h2
  have h₁₂₃ : Real.log x = (5 / 3 : ℝ) * Real.log y := by
    have h₁₂₄ : Real.log x = (5 / 3 : ℝ) * Real.log y := by
      apply_fun (fun t => (3 : ℝ) / 5 * t) at h₁₂₂
      ring_nf at h₁₂₂ ⊢
      <;> nlinarith
    exact h₁₂₄
  have h₁₂₄ : Real.log x = Real.log y + Real.log z := h₁₂₁
  have h₁₂₅ : (5 / 3 : ℝ) * Real.log y = Real.log y + Real.log z := by linarith
  have h₁₂₆ : Real.log z = (2 / 3 : ℝ) * Real.log y := by linarith
  exact h₁₂₆

lemma log_w_div_log_z_eq_60 (x y z w : ℕ)
    (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) :
    Real.log w / Real.log z = 60 := by
  have h₁₃₁ : Real.log w = 40 * Real.log y := log_w_eq_40_log_y x y z w ht hw h0 h1 h2
  have h₁₃₂ : Real.log z = (2 / 3 : ℝ) * Real.log y :=
    log_z_relation x y z w ht hw h0 h1 h2
  have h₁₃₃ : Real.log w / Real.log z = 60 := by
    rw [h₁₃₁, h₁₃₂]
    have h₁₃₄ : Real.log y ≠ 0 := log_y_ne_zero x y z w ht hw h0 h1 h2
    field_simp [h₁₃₄]
    <;> ring_nf
    <;> field_simp [h₁₃₄]
    <;> nlinarith
  exact h₁₃₃

theorem aime_1983_p1 (x y z w : ℕ) (ht : 1 < x ∧ 1 < y ∧ 1 < z) (hw : 0 ≤ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) : Real.log w / Real.log z = 60 := by
  exact log_w_div_log_z_eq_60 x y z w ht hw h0 h1 h2
\end{lstlisting}
\end{thought}\section{algebra abpbcpcageq3 sumaonsqrtapbgeq3onsqrt2}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma sum_ge_three (a b c : ℝ) (h₀ : 0 < a ∧ 0 < b ∧ 0 < c)
    (h₁ : 3 ≤ a * b + b * c + c * a) : a + b + c ≥ 3 := by
  nlinarith [sq_nonneg (a - b), sq_nonneg (b - c), sq_nonneg (c - a),
    mul_pos h₀.1 h₀.2.1, mul_pos h₀.2.1 h₀.2.2, mul_pos h₀.2.2 h₀.1,
    sq_nonneg (a + b + c), sq_nonneg (a + b + c - 3)]


lemma main_ineq (a b c : ℝ) (h₀ : 0 < a ∧ 0 < b ∧ 0 < c) :
    a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a) ≥ 3 / Real.sqrt 2 := by
  have h₂ : 0 < a := by linarith
  have h₃ : 0 < b := by linarith
  have h₄ : 0 < c := by linarith
  have h₅ : 0 < a + b := by linarith
  have h₆ : 0 < b + c := by linarith
  have h₇ : 0 < c + a := by linarith
  have h₈ : 0 < Real.sqrt (a + b) := Real.sqrt_pos.mpr h₅
  have h₉ : 0 < Real.sqrt (b + c) := Real.sqrt_pos.mpr h₆
  have h₁₀ : 0 < Real.sqrt (c + a) := Real.sqrt_pos.mpr h₇
  have h₁₁ : 0 < Real.sqrt 2 := Real.sqrt_pos.mpr (by norm_num)
  have h₁₂ : 0 < Real.sqrt (a + b) * Real.sqrt (b + c) * Real.sqrt (c + a) := by positivity
  have h₁₃ : 0 < Real.sqrt 2 * (Real.sqrt (a + b) * Real.sqrt (b + c) * Real.sqrt (c + a)) := by positivity

  have h₁₄ : a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a) ≥ 3 / Real.sqrt 2 := by
    have h₁₅ : Real.sqrt 2 > 0 := by positivity
    have h₁₆ : Real.sqrt (a + b) > 0 := by positivity
    have h₁₇ : Real.sqrt (b + c) > 0 := by positivity
    have h₁₈ : Real.sqrt (c + a) > 0 := by positivity
    have h₁₉ : Real.sqrt (a + b) * Real.sqrt (b + c) * Real.sqrt (c + a) > 0 := by positivity

    have h₂₀ : a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a) ≥ 3 / Real.sqrt 2 := by
      have h₂₁ : a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a) ≥ 3 / Real.sqrt 2 := by
        have h₂₂ : 0 < Real.sqrt (a + b) * Real.sqrt (b + c) * Real.sqrt (c + a) := by positivity
        have h₂₃ : 0 < Real.sqrt 2 * (Real.sqrt (a + b) * Real.sqrt (b + c) * Real.sqrt (c + a)) := by positivity

        have h₂₄ : (a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a)) ≥ 3 / Real.sqrt 2 := by
          have h₂₅ : (a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a)) ≥ 3 / Real.sqrt 2 := by
            have h₂₆ : (a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a)) ≥ 3 / Real.sqrt 2 := by
              
              have h₂₇ : 0 < Real.sqrt (a + b) * Real.sqrt (b + c) := by positivity
              have h₂₈ : 0 < Real.sqrt (b + c) * Real.sqrt (c + a) := by positivity
              have h₂₉ : 0 < Real.sqrt (c + a) * Real.sqrt (a + b) := by positivity

              have h₃₀ : Real.sqrt (a + b) ≤ Real.sqrt 2 * ((a + b + 1) / 2) := by
                apply Real.sqrt_le_iff.mpr
                constructor
                · positivity
                · nlinarith [Real.sq_sqrt (show 0 ≤ 2 by norm_num),
                    Real.sqrt_nonneg 2,
                    sq_nonneg (a + b - 1)]
              have h₃₁ : Real.sqrt (b + c) ≤ Real.sqrt 2 * ((b + c + 1) / 2) := by
                apply Real.sqrt_le_iff.mpr
                constructor
                · positivity
                · nlinarith [Real.sq_sqrt (show 0 ≤ 2 by norm_num),
                    Real.sqrt_nonneg 2,
                    sq_nonneg (b + c - 1)]
              have h₃₂ : Real.sqrt (c + a) ≤ Real.sqrt 2 * ((c + a + 1) / 2) := by
                apply Real.sqrt_le_iff.mpr
                constructor
                · positivity
                · nlinarith [Real.sq_sqrt (show 0 ≤ 2 by norm_num),
                    Real.sqrt_nonneg 2,
                    sq_nonneg (c + a - 1)]

              have h₃₃ : a / Real.sqrt (a + b) ≥ a / (Real.sqrt 2 * ((a + b + 1) / 2)) := by
                apply div_le_div_of_le_left (by positivity) (by positivity)
                linarith
              have h₃₄ : b / Real.sqrt (b + c) ≥ b / (Real.sqrt 2 * ((b + c + 1) / 2)) := by
                apply div_le_div_of_le_left (by positivity) (by positivity)
                linarith
              have h₃₅ : c / Real.sqrt (c + a) ≥ c / (Real.sqrt 2 * ((c + a + 1) / 2)) := by
                apply div_le_div_of_le_left (by positivity) (by positivity)
                linarith

              have h₃₆ : a / (Real.sqrt 2 * ((a + b + 1) / 2)) = (2 * a) / (Real.sqrt 2 * (a + b + 1)) := by
                field_simp [h₁₅.ne']
                <;> ring_nf
                <;> field_simp [h₁₅.ne']
                <;> ring
              have h₃₇ : b / (Real.sqrt 2 * ((b + c + 1) / 2)) = (2 * b) / (Real.sqrt 2 * (b + c + 1)) := by
                field_simp [h₁₅.ne']
                <;> ring_nf
                <;> field_simp [h₁₅.ne']
                <;> ring
              have h₃₈ : c / (Real.sqrt 2 * ((c + a + 1) / 2)) = (2 * c) / (Real.sqrt 2 * (c + a + 1)) := by
                field_simp [h₁₅.ne']
                <;> ring_nf
                <;> field_simp [h₁₅.ne']
                <;> ring

              have h₃₉ : a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a) ≥
                  (2 * a) / (Real.sqrt 2 * (a + b + 1)) + (2 * b) / (Real.sqrt 2 * (b + c + 1)) +
                    (2 * c) / (Real.sqrt 2 * (c + a + 1)) := by
                linarith [h₃₃, h₃₄, h₃₅, h₃₆, h₃₇, h₃₈]

              have h₄₀ : (2 * a) / (Real.sqrt 2 * (a + b + 1)) + (2 * b) / (Real.sqrt 2 * (b + c + 1)) +
                  (2 * c) / (Real.sqrt 2 * (c + a + 1)) ≥ 3 / Real.sqrt 2 := by
                have h₄₁ : 0 < Real.sqrt 2 := by positivity
                have h₄₂ : 0 < Real.sqrt 2 * (a + b + 1) := by positivity
                have h₄₃ : 0 < Real.sqrt 2 * (b + c + 1) := by positivity
                have h₄₄ : 0 < Real.sqrt 2 * (c + a + 1) := by positivity
                have h₄₅ : 0 < Real.sqrt 2 * (a + b + 1) * (Real.sqrt 2 * (b + c + 1)) := by positivity
                have h₄₆ : 0 < Real.sqrt 2 * (a + b + 1) * (Real.sqrt 2 * (b + c + 1)) *
                    (Real.sqrt 2 * (c + a + 1)) := by positivity
                field_simp [h₄₁.ne', h₄₂.ne', h₄₃.ne', h₄₄.ne']
                rw [div_le_div_iff (by positivity) (by positivity)]
                nlinarith [sq_nonneg (a - b), sq_nonneg (b - c), sq_nonneg (c - a),
                  Real.sq_sqrt (show 0 ≤ 2 by norm_num),
                  mul_nonneg h₂.le h₃.le, mul_nonneg h₃.le h₄.le, mul_nonneg h₄.le h₂.le,
                  mul_nonneg (sq_nonneg (a - b)) h₄.le, mul_nonneg (sq_nonneg (b - c)) h₂.le,
                  mul_nonneg (sq_nonneg (c - a)) h₃.le,
                  mul_nonneg (sq_nonneg (a - b)) h₃.le, mul_nonneg (sq_nonneg (b - c)) h₄.le,
                  mul_nonneg (sq_nonneg (c - a)) h₂.le]
              linarith [h₃₉, h₄₀]
            linarith [h₂₆]
          linarith [h₂₅]
        linarith [h₂₄]
      linarith [h₂₁]
    linarith [h₂₀]
  linarith [h₁₄]

theorem algebra_abpbcpcageq3_sumaonsqrtapbgeq3onsqrt2 (a b c : ℝ) (h₀ : 0 < a ∧ 0 < b ∧ 0 < c)
    (h₁ : 3 ≤ a * b + b * c + c * a) :
    3 / Real.sqrt 2 ≤ a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a) := by
  have h₂ : a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a) ≥ 3 / Real.sqrt 2 :=
    main_ineq a b c h₀
  linarith [h₂]
\end{lstlisting}
\end{thought}\section{mathd numbertheory 328}
\begin{thought}
\begin{lstlisting}[language=prompt,belowskip=-6pt]
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

lemma pow_mod_5_999999 : 5 ^ 999999 % 7 = 6 := by
  norm_num [pow_succ, pow_mul, Nat.mul_mod, Nat.pow_mod, Nat.add_mod]
  <;> rfl
  <;> decide

theorem mathd_numbertheory_328 : 5 ^ 999999 % 7 = 6 := by
  exact pow_mod_5_999999
\end{lstlisting}
\end{thought}